<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang xml:lang>
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="mpark/wg21" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2019-08-06" />
  <title>Cancellation is not an Error</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  { background-color: #f6f8fa; }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span. { } /* Normal */
code span.al { color: #ff0000; } /* Alert */
code span.an { } /* Annotation */
code span.at { } /* Attribute */
code span.bn { color: #9f6807; } /* BaseN */
code span.bu { color: #9f6807; } /* BuiltIn */
code span.cf { color: #00607c; } /* ControlFlow */
code span.ch { color: #9f6807; } /* Char */
code span.cn { } /* Constant */
code span.co { color: #008000; font-style: italic; } /* Comment */
code span.cv { color: #008000; font-style: italic; } /* CommentVar */
code span.do { color: #008000; } /* Documentation */
code span.dt { color: #00607c; } /* DataType */
code span.dv { color: #9f6807; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #9f6807; } /* Float */
code span.fu { } /* Function */
code span.im { } /* Import */
code span.in { color: #008000; } /* Information */
code span.kw { color: #00607c; } /* Keyword */
code span.op { color: #af1915; } /* Operator */
code span.ot { } /* Other */
code span.pp { color: #6f4e37; } /* Preprocessor */
code span.re { } /* RegionMarker */
code span.sc { color: #9f6807; } /* SpecialChar */
code span.ss { color: #9f6807; } /* SpecialString */
code span.st { color: #9f6807; } /* String */
code span.va { } /* Variable */
code span.vs { color: #9f6807; } /* VerbatimString */
code span.wa { color: #008000; font-weight: bold; } /* Warning */
code.diff {color: #898887}
code.diff span.va {color: #006e28}
code.diff span.st {color: #bf0303}
  </style>
  <style type="text/css">
body {
margin: 5em;
font-family: serif;

hyphens: auto;
line-height: 1.35;
}
div.wrapper {
max-width: 60em;
margin: auto;
}
ul {
list-style-type: none;
padding-left: 2em;
margin-top: -0.2em;
margin-bottom: -0.2em;
}
a {
text-decoration: none;
color: #4183C4;
}
a.hidden_link {
text-decoration: none;
color: inherit;
}
li {
margin-top: 0.6em;
margin-bottom: 0.6em;
}
h1, h2, h3, h4 {
position: relative;
line-height: 1;
}
a.self-link {
position: absolute;
top: 0;
left: calc(-1 * (3.5rem - 26px));
width: calc(3.5rem - 26px);
height: 2em;
text-align: center;
border: none;
transition: opacity .2s;
opacity: .5;
font-family: sans-serif;
font-weight: normal;
font-size: 83%;
}
a.self-link:hover { opacity: 1; }
a.self-link::before { content: "§"; }
ul > li:before {
content: "\2014";
position: absolute;
margin-left: -1.5em;
}
:target { background-color: #C9FBC9; }
:target .codeblock { background-color: #C9FBC9; }
:target ul { background-color: #C9FBC9; }
.abbr_ref { float: right; }
.folded_abbr_ref { float: right; }
:target .folded_abbr_ref { display: none; }
:target .unfolded_abbr_ref { float: right; display: inherit; }
.unfolded_abbr_ref { display: none; }
.secnum { display: inline-block; min-width: 35pt; }
.header-section-number { display: inline-block; min-width: 35pt; }
.annexnum { display: block; }
div.sourceLinkParent {
float: right;
}
a.sourceLink {
position: absolute;
opacity: 0;
margin-left: 10pt;
}
a.sourceLink:hover {
opacity: 1;
}
a.itemDeclLink {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
opacity: 0;
}
a.itemDeclLink:hover { opacity: 1; }
span.marginalizedparent {
position: relative;
left: -5em;
}
li span.marginalizedparent { left: -7em; }
li ul > li span.marginalizedparent { left: -9em; }
li ul > li ul > li span.marginalizedparent { left: -11em; }
li ul > li ul > li ul > li span.marginalizedparent { left: -13em; }
div.footnoteNumberParent {
position: relative;
left: -4.7em;
}
a.marginalized {
position: absolute;
font-size: 75%;
text-align: right;
width: 5em;
}
a.enumerated_item_num {
position: relative;
left: -3.5em;
display: inline-block;
margin-right: -3em;
text-align: right;
width: 3em;
}
div.para { margin-bottom: 0.6em; margin-top: 0.6em; text-align: justify; }
div.section { text-align: justify; }
div.sentence { display: inline; }
span.indexparent {
display: inline;
position: relative;
float: right;
right: -1em;
}
a.index {
position: absolute;
display: none;
}
a.index:before { content: "⟵"; }

a.index:target {
display: inline;
}
.indexitems {
margin-left: 2em;
text-indent: -2em;
}
div.itemdescr {
margin-left: 3em;
}
.bnf {
font-family: serif;
margin-left: 40pt;
margin-top: 0.5em;
margin-bottom: 0.5em;
}
.ncbnf {
font-family: serif;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
}
.ncsimplebnf {
font-family: serif;
font-style: italic;
margin-top: 0.5em;
margin-bottom: 0.5em;
margin-left: 40pt;
background: inherit; 
}
span.textnormal {
font-style: normal;
font-family: serif;
white-space: normal;
display: inline-block;
}
span.rlap {
display: inline-block;
width: 0px;
}
span.descr { font-style: normal; font-family: serif; }
span.grammarterm { font-style: italic; }
span.term { font-style: italic; }
span.terminal { font-family: monospace; font-style: normal; }
span.nonterminal { font-style: italic; }
span.tcode { font-family: monospace; font-style: normal; }
span.textbf { font-weight: bold; }
span.textsc { font-variant: small-caps; }
a.nontermdef { font-style: italic; font-family: serif; }
span.emph { font-style: italic; }
span.techterm { font-style: italic; }
span.mathit { font-style: italic; }
span.mathsf { font-family: sans-serif; }
span.mathrm { font-family: serif; font-style: normal; }
span.textrm { font-family: serif; }
span.textsl { font-style: italic; }
span.mathtt { font-family: monospace; font-style: normal; }
span.mbox { font-family: serif; font-style: normal; }
span.ungap { display: inline-block; width: 2pt; }
span.textit { font-style: italic; }
span.texttt { font-family: monospace; }
span.tcode_in_codeblock { font-family: monospace; font-style: normal; }
span.phantom { color: white; }

span.math { font-style: normal; }
span.mathblock {
display: block;
margin-left: auto;
margin-right: auto;
margin-top: 1.2em;
margin-bottom: 1.2em;
text-align: center;
}
span.mathalpha {
font-style: italic;
}
span.synopsis {
font-weight: bold;
margin-top: 0.5em;
display: block;
}
span.definition {
font-weight: bold;
display: block;
}
.codeblock {
margin-left: 1.2em;
line-height: 127%;
}
.outputblock {
margin-left: 1.2em;
line-height: 127%;
}
div.itemdecl {
margin-top: 2ex;
}
code.itemdeclcode {
white-space: pre;
display: block;
}
span.textsuperscript {
vertical-align: super;
font-size: smaller;
line-height: 0;
}
.footnotenum { vertical-align: super; font-size: smaller; line-height: 0; }
.footnote {
font-size: small;
margin-left: 2em;
margin-right: 2em;
margin-top: 0.6em;
margin-bottom: 0.6em;
}
div.minipage {
display: inline-block;
margin-right: 3em;
}
div.numberedTable {
text-align: center;
margin: 2em;
}
div.figure {
text-align: center;
margin: 2em;
}
table {
border: 1px solid black;
border-collapse: collapse;
margin-left: auto;
margin-right: auto;
margin-top: 0.8em;
text-align: left;
hyphens: none; 
}
td, th {
padding-left: 1em;
padding-right: 1em;
vertical-align: top;
}
td.empty {
padding: 0px;
padding-left: 1px;
}
td.left {
text-align: left;
}
td.right {
text-align: right;
}
td.center {
text-align: center;
}
td.justify {
text-align: justify;
}
td.border {
border-left: 1px solid black;
}
tr.rowsep, td.cline {
border-top: 1px solid black;
}
tr.even, tr.odd {
border-bottom: 1px solid black;
}
tr.capsep {
border-top: 3px solid black;
border-top-style: double;
}
tr.header {
border-bottom: 3px solid black;
border-bottom-style: double;
}
th {
border-bottom: 1px solid black;
}
span.centry {
font-weight: bold;
}
div.table {
display: block;
margin-left: auto;
margin-right: auto;
text-align: center;
width: 90%;
}
span.indented {
display: block;
margin-left: 2em;
margin-bottom: 1em;
margin-top: 1em;
}
ol.enumeratea { list-style-type: none; background: inherit; }
ol.enumerate { list-style-type: none; background: inherit; }

code.sourceCode > span { display: inline; }

div#refs p { padding-left: 32px; text-indent: -32px; }
</style>
  <link href="data:image/vnd.microsoft.icon;base64,AAABAAIAEBAAAAEAIABoBAAAJgAAACAgAAABACAAqBAAAI4EAAAoAAAAEAAAACAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAVoJEAN6CRADegkQAWIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wCCRAAAgkQAAIJEAACCRAAsgkQAvoJEAP+CRAD/gkQA/4JEAP+CRADAgkQALoJEAACCRAAAgkQAAP///wD///8AgkQAAIJEABSCRACSgkQA/IJEAP99PQD/dzMA/3czAP99PQD/gkQA/4JEAPyCRACUgkQAFIJEAAD///8A////AHw+AFiBQwDqgkQA/4BBAP9/PxP/uZd6/9rJtf/bybX/upd7/39AFP+AQQD/gkQA/4FDAOqAQgBc////AP///wDKklv4jlEa/3o7AP+PWC//8+3o///////////////////////z7un/kFox/35AAP+GRwD/mVYA+v///wD///8A0Zpk+NmibP+0d0T/8evj///////+/fv/1sKz/9bCs//9/fr//////+/m2/+NRwL/nloA/5xYAPj///8A////ANKaZPjRmGH/5cKh////////////k149/3UwAP91MQD/lmQ//86rhv+USg3/m1YA/5hSAP+bVgD4////AP///wDSmmT4zpJY/+/bx///////8+TV/8mLT/+TVx//gkIA/5lVAP+VTAD/x6B//7aEVv/JpH7/s39J+P///wD///8A0ppk+M6SWP/u2sf///////Pj1f/Nj1T/2KFs/8mOUv+eWhD/lEsA/8aee/+0glT/x6F7/7J8Rvj///8A////ANKaZPjRmGH/48Cf///////+/v7/2qt//82PVP/OkFX/37KJ/86siv+USg7/mVQA/5hRAP+bVgD4////AP///wDSmmT40ppk/9CVXP/69O////////7+/v/x4M//8d/P//7+/f//////9u7n/6tnJf+XUgD/nFgA+P///wD///8A0ppk+NKaZP/RmWL/1qNy//r07///////////////////////+vXw/9akdP/Wnmn/y5FY/6JfFvj///8A////ANKaZFTSmmTo0ppk/9GYYv/Ql1//5cWm//Hg0P/x4ND/5cWm/9GXYP/RmGH/0ppk/9KaZOjVnmpY////AP///wDSmmQA0ppkEtKaZI7SmmT60ppk/9CWX//OkVb/zpFW/9CWX//SmmT/0ppk/NKaZJDSmmQS0ppkAP///wD///8A0ppkANKaZADSmmQA0ppkKtKaZLrSmmT/0ppk/9KaZP/SmmT/0ppkvNKaZCrSmmQA0ppkANKaZAD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkUtKaZNzSmmTc0ppkVNKaZADSmmQA0ppkANKaZADSmmQA////AP5/AAD4HwAA4AcAAMADAACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAMADAADgBwAA+B8AAP5/AAAoAAAAIAAAAEAAAAABACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAyCRACMgkQA6oJEAOqCRACQgkQAEIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRABigkQA5oJEAP+CRAD/gkQA/4JEAP+CRADqgkQAZoJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAA4gkQAwoJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQAxIJEADyCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAAgkQAAP///wD///8A////AP///wCCRAAAgkQAAIJEAACCRAAAgkQAAIJEAACCRAAWgkQAmIJEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAJyCRAAYgkQAAIJEAACCRAAAgkQAAIJEAACCRAAA////AP///wD///8A////AIJEAACCRAAAgkQAAIJEAACCRAAAgkQAdIJEAPCCRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAP+CRAD/gkQA/4JEAPSCRAB4gkQAAIJEAACCRAAAgkQAAIJEAAD///8A////AP///wD///8AgkQAAIJEAACCRAAAgkQASoJEANKCRAD/gkQA/4JEAP+CRAD/g0YA/39AAP9zLgD/bSQA/2shAP9rIQD/bSQA/3MuAP9/PwD/g0YA/4JEAP+CRAD/gkQA/4JEAP+CRADUgkQAToJEAACCRAAAgkQAAP///wD///8A////AP///wB+PwAAgkUAIoJEAKiCRAD/gkQA/4JEAP+CRAD/hEcA/4BBAP9sIwD/dTAA/5RfKv+viF7/vp56/76ee/+wiF7/lWAr/3YxAP9sIwD/f0AA/4RHAP+CRAD/gkQA/4JEAP+CRAD/gkQArIJEACaBQwAA////AP///wD///8A////AIBCAEBzNAD6f0EA/4NFAP+CRAD/gkQA/4VIAP92MwD/bSUA/6N1Tv/ezsL/////////////////////////////////38/D/6V3Uv9uJgD/dTEA/4VJAP+CRAD/gkQA/4JEAP+BQwD/fUAA/4FDAEj///8A////AP///wD///8AzJRd5qBlKf91NgD/dDUA/4JEAP+FSQD/cy4A/3YyAP/PuKP//////////////////////////////////////////////////////9K7qP94NQD/ciwA/4VJAP+CRAD/fkEA/35BAP+LSwD/mlYA6v///wD///8A////AP///wDdpnL/4qx3/8KJUv+PUhf/cTMA/3AsAP90LgD/4dK+/////////////////////////////////////////////////////////////////+TYxf91MAD/dTIA/31CAP+GRwD/llQA/6FcAP+gWwD8////AP///wD///8A////ANGZY/LSm2X/4ap3/92mcP+wdT3/byQA/8mwj////////////////////////////////////////////////////////////////////////////+LYxv9zLgP/jUoA/59bAP+hXAD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/RmWL/1p9q/9ubXv/XqXj////////////////////////////7+fD/vZyG/6BxS/+gcUr/vJuE//r37f//////////////////////3MOr/5dQBf+dVQD/nVkA/5xYAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmWP/yohJ//jo2P//////////////////////4NTG/4JDFf9lGAD/bSQA/20kAP9kGAD/fz8S/+Xb0f//////5NG9/6txN/+LOgD/m1QA/51aAP+cWAD/m1cA/5xYAP+cWADy////AP///wD///8A////ANKaZPLSmmT/0ppk/8+TWf/Unmv//v37//////////////////////+TWRr/VwsA/35AAP+ERgD/g0UA/4JGAP9lHgD/kFga/8KXX/+TRwD/jT4A/49CAP+VTQD/n10A/5xYAP+OQQD/lk4A/55cAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/y4tO/92yiP//////////////////////8NnE/8eCQP+rcTT/ez0A/3IyAP98PgD/gEMA/5FSAP+USwD/jj8A/5lUAP+JNwD/yqV2/694Mf+HNQD/jkAA/82rf/+laBj/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/LiUr/4byY///////////////////////gupX/0I5P/+Wuev/Lklz/l1sj/308AP+QSwD/ol0A/59aAP+aVQD/k0oA/8yoh///////+fXv/6pwO//Lp3v///////Pr4f+oay7y////AP///wD///8A////ANKaZPLSmmT/0ppk/8uJSv/hvJj//////////////////////+G7l//Jhkb/0ppk/96nc//fqXX/x4xO/6dkFP+QSQD/llEA/5xXAP+USgD/yaOA///////38uv/qG05/8ijdv//////8efb/6ZpLPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/zIxO/9yxh///////////////////////7dbA/8iEQf/Sm2X/0Zlj/9ScZv/eqHf/2KJv/7yAQf+XTgD/iToA/5lSAP+JNgD/yKFv/611LP+HNQD/jT8A/8qmeP+kZRT/jT4A8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/Pk1n/1J5q//78+//////////////////+/fv/1aFv/8iEQv/Tm2b/0ppl/9GZY//Wn2z/1pZc/9eldf/Bl2b/kUcA/4w9AP+OQAD/lUwA/59eAP+cWQD/jT8A/5ZOAP+eXADy////AP///wD///8A////ANKaZPLSmmT/0ppk/9KZY//KiEn/8d/P///////////////////////47+f/05tm/8iCP//KiEj/yohJ/8eCP//RmGH//vfy///////n1sP/rXQ7/4k4AP+TTAD/nVoA/5xYAP+cVwD/nFgA/5xYAPL///8A////AP///wD///8A0ppk8tKaZP/SmmT/0ptl/8uLTf/aq37////////////////////////////+/fz/6c2y/961jv/etY7/6Myx//78+v//////////////////////3MWv/5xXD/+ORAD/mFQA/51ZAP+cWAD/nFgA8v///wD///8A////AP///wDSmmTy0ppk/9KaZP/SmmT/0ppk/8mFRP/s1b//////////////////////////////////////////////////////////////////////////////+PD/0JFU/7NzMv+WUQD/kUsA/5tXAP+dWQDy////AP///wD///8A////ANKaZP/SmmT/0ppk/9KaZP/Sm2X/z5NZ/8yMT//z5NX/////////////////////////////////////////////////////////////////9Ofa/8yNUP/UmGH/36p5/8yTWv+qaSD/kksA/5ROAPz///8A////AP///wD///8A0ppk5NKaZP/SmmT/0ppk/9KaZP/TnGf/zY9T/82OUv/t1sD//////////////////////////////////////////////////////+7Yw//OkFX/zI5R/9OcZ//SmmP/26V0/9ymdf/BhUf/ol8R6P///wD///8A////AP///wDSmmQ80ppk9tKaZP/SmmT/0ppk/9KaZP/TnGj/zpFW/8qJSv/dson/8uHS//////////////////////////////////Lj0//etIv/y4lL/86QVf/TnGj/0ppk/9KaZP/RmWP/05xn/9ymdfjUnWdC////AP///wD///8A////ANKaZADSmmQc0ppkotKaZP/SmmT/0ppk/9KaZP/Tm2b/0Zli/8qJSf/NjlH/16Z3/+G8mP/myKr/5siq/+G8mP/Xp3f/zY5S/8qISf/RmGH/05tm/9KaZP/SmmT/0ppk/9KaZP/SmmSm0pljINWdaQD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkQtKaZMrSmmT/0ppk/9KaZP/SmmT/0ptl/9GYYf/Nj1P/y4lL/8qISP/KiEj/y4lK/82PU//RmGH/0ptl/9KaZP/SmmT/0ppk/9KaZP/SmmTO0ppkRtKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZGzSmmTu0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmTw0ppkcNKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZBLSmmSQ0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppklNKaZBTSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP///wD///8A0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQy0ppkutKaZP/SmmT/0ppk/9KaZP/SmmT/0ppk/9KaZP/SmmT/0ppkvtKaZDbSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkAP///wD///8A////AP///wDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkXNKaZODSmmT/0ppk/9KaZP/SmmT/0ppk5NKaZGDSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA////AP///wD///8A////ANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkBtKaZIbSmmTo0ppk6tKaZIrSmmQK0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZADSmmQA0ppkANKaZAD///8A////AP/8P///+B///+AH//+AAf//AAD//AAAP/AAAA/gAAAHwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA8AAAAPAAAADwAAAA+AAAAfwAAAP/AAAP/8AAP//gAH//+AH///4H////D//" rel="icon" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  
</head>
<body>
<div class="wrapper">
<header id="title-block-header">
<h1 class="title" style="text-align:center">Cancellation is not an Error</h1>

<table style="border:none;float:right">
  <tr>
    <td>Document #: </td>
    <td>D1677R1</td>
  </tr>
  <tr>
    <td>Date: </td>
    <td>2019-08-06</td>
  </tr>
  <tr>
    <td style="vertical-align:top">Project: </td>
    <td>Programming Language C++<br>
      SG1 Concurrency and Parallelism<br>
      SG13 IO<br>
      LEWG Library Evolution<br>
      EWG Evolution<br>
    </td>
  </tr>
  <tr>
    <td style="vertical-align:top">Reply-to: </td>
    <td>
      Kirk Shoop<br>&lt;<a href="mailto:kirkshoop@fb.com" class="email">kirkshoop@fb.com</a>&gt;<br>
    </td>
  </tr>
</table>

</header>
<div style="clear:both">
<div id="TOC" role="doc-toc">
<h1 id="toctitle">Contents</h1>
<ul>
<li><a href="#changelog"><span class="toc-section-number">1</span> Changelog<span></span></a></li>
<li><a href="#introduction"><span class="toc-section-number">2</span> Introduction<span></span></a></li>
<li><a href="#background"><span class="toc-section-number">3</span> Background<span></span></a></li>
<li><a href="#motivation"><span class="toc-section-number">4</span> Motivation<span></span></a><ul>
<li><a href="#stack-unwinding"><span class="toc-section-number">4.1</span> stack unwinding<span></span></a><ul>
<li><a href="#c-exception"><span class="toc-section-number">4.1.1</span> C++ exception<span></span></a></li>
<li><a href="#non-cpp-exception"><span class="toc-section-number">4.1.2</span> non-cpp-exception<span></span></a></li>
</ul></li>
<li><a href="#algorithms-that-cancel"><span class="toc-section-number">4.2</span> Algorithms that cancel<span></span></a><ul>
<li><a href="#when_any"><span class="toc-section-number">4.2.1</span> <code>when_any()</code><span></span></a></li>
</ul></li>
<li><a href="#algorithms-that-respond-to-errors"><span class="toc-section-number">4.3</span> Algorithms that respond to errors<span></span></a><ul>
<li><a href="#a-generic-retry-algorithm"><span class="toc-section-number">4.3.1</span> a generic <code>retry()</code> algorithm<span></span></a></li>
</ul></li>
<li><a href="#callbacks"><span class="toc-section-number">4.4</span> Callbacks<span></span></a><ul>
<li><a href="#destructor-style"><span class="toc-section-number">4.4.1</span> destructor style<span></span></a></li>
<li><a href="#value-and-error-arguments-style"><span class="toc-section-number">4.4.2</span> value and error arguments style<span></span></a></li>
<li><a href="#stdexpected-style"><span class="toc-section-number">4.4.3</span> <code>std::expected</code> style<span></span></a></li>
<li><a href="#multiple-function-style"><span class="toc-section-number">4.4.4</span> multiple function style<span></span></a></li>
<li><a href="#gratuitous"><span class="toc-section-number">4.4.5</span> gratuitous<span></span></a></li>
</ul></li>
<li><a href="#exception-noise"><span class="toc-section-number">4.5</span> Exception noise<span></span></a></li>
<li><a href="#sync-functions-not-a-typo"><span class="toc-section-number">4.6</span> sync functions (not a typo)<span></span></a><ul>
<li><a href="#coroutine-generator"><span class="toc-section-number">4.6.1</span> coroutine generator<span></span></a></li>
<li><a href="#stdoptional"><span class="toc-section-number">4.6.2</span> <code>std::optional</code><span></span></a></li>
</ul></li>
<li><a href="#examples"><span class="toc-section-number">4.7</span> Examples<span></span></a><ul>
<li><a href="#fgh"><span class="toc-section-number">4.7.1</span> <code>f(g(h()))</code><span></span></a></li>
</ul></li>
</ul></li>
<li><a href="#conclusions"><span class="toc-section-number">5</span> Conclusions<span></span></a><ul>
<li><a href="#function-output"><span class="toc-section-number">5.1</span> Function output<span></span></a><ul>
<li><a href="#values"><span class="toc-section-number">5.1.1</span> Values<span></span></a></li>
<li><a href="#exceptions"><span class="toc-section-number">5.1.2</span> Exceptions<span></span></a></li>
<li><a href="#multiplexing"><span class="toc-section-number">5.1.3</span> Multiplexing<span></span></a></li>
</ul></li>
<li><a href="#contrast-function-taking-a-callback-with-function"><span class="toc-section-number">5.2</span> Contrast function-taking-a-callback with function<span></span></a></li>
</ul></li>
<li><a href="#proposals"><span class="toc-section-number">6</span> Proposals<span></span></a><ul>
<li><a href="#library"><span class="toc-section-number">6.1</span> Library<span></span></a></li>
<li><a href="#language"><span class="toc-section-number">6.2</span> Language<span></span></a><ul>
<li><a href="#co_done-catch_co_done"><span class="toc-section-number">6.2.1</span> co_done &amp; catch_co_done<span></span></a></li>
<li><a href="#scope-library"><span class="toc-section-number">6.2.2</span> scope library<span></span></a></li>
<li><a href="#scope_success-scope_fail-scope_done-blocks"><span class="toc-section-number">6.2.3</span> scope_success, scope_fail, scope_done blocks<span></span></a></li>
<li><a href="#afterthought-converting-undefined-behaviour-to-defined-behaviour"><span class="toc-section-number">6.2.4</span> Afterthought: converting undefined behaviour to defined behaviour<span></span></a></li>
</ul></li>
</ul></li>
<li><a href="#credits"><span class="toc-section-number">7</span> Credits<span></span></a></li>
<li><a href="#references"><span class="toc-section-number">8</span> References<span></span></a></li>
</ul>
</div>
<h1 id="changelog"><span class="header-section-number">1</span> Changelog<a href="#changelog" class="self-link"></a></h1>
<p><strong>R1</strong></p>
<ul>
<li><input type="checkbox" disabled checked></input>
Use bibliography for Cologne paper references</li>
<li><input type="checkbox" disabled checked></input>
add stack-frame analogy for callbacks</li>
<li><input type="checkbox" disabled checked></input>
add <code>fiber_context</code> unwind mechanisms</li>
<li><input type="checkbox" disabled checked></input>
add section on non-cpp-exception</li>
<li><input type="checkbox" disabled checked></input>
add code to show <code>throw(...)</code> usages that break unwind by exception</li>
<li><input type="checkbox" disabled checked></input>
fix code examples (apply Lewis’ feedback)</li>
<li><input type="checkbox" disabled checked></input>
add <code>f(g(h()))</code>, <code>generator</code> &amp; <code>retry</code> examples</li>
<li><input type="checkbox" disabled checked></input>
switch the term neither-a-result-nor-an-error to serendipitous-success</li>
</ul>
<h1 id="introduction"><span class="header-section-number">2</span> Introduction<a href="#introduction" class="self-link"></a></h1>
<p>One of the basis operations for any async function is cancellation. In this paper we explore the uses of cancellation to determine how to represent the result of a cancelled async function (the mechanism to signal a request for cancellation is covered by <code>stop_source</code> in C++20). In this paper a cancelled result is described as an instance of serendipitous-success (<a href="#credits">Credits</a> go to Lisa Lippincott for coining this term).</p>
<p>The ideas in this paper have proved to be exceedingly difficult to communicate. Each time this conversation is begun with a new person the same process of exploring the options to represent a cancelled result from a function is repeated.</p>
<p>It is usually easy to discard using an <code>optional&lt;T&gt;</code> return value. This ease is due to the noise it introduces, so we can skip the much harder task of explaining that the return value is a poor representation of a cancelled result.</p>
<p>We cannot avoid the hard task of explaining why something like a <code>cancelled_error</code> exception or <code>error_code</code> is a poor representation of a cancelled result, because it does not appear at first glance to introduce a lot of noise. This paper is focused on explaining why errors are a bad way to represent a cancelled result.</p>
<blockquote>
<p>NOTE: This paper does not depend on a particular representation of an async function. async functions may return Futures, Executors, Senders, Awaitables or something completely different. While this paper may use some of these representations in example code, they are used for exposition only.</p>
</blockquote>
<h1 id="background"><span class="header-section-number">3</span> Background<a href="#background" class="self-link"></a></h1>
<p>The <code>jthread</code> paper <span class="citation" data-cites="P0660R9">[<a href="#ref-P0660R9" role="doc-biblioref">P0660R9</a>]</span> and the <code>fiber_context</code> paper revisions <span class="citation" data-cites="P0876R5">[<a href="#ref-P0876R5" role="doc-biblioref">P0876R5</a>]</span> &amp; <span class="citation" data-cites="P0876R6">[<a href="#ref-P0876R6" role="doc-biblioref">P0876R6</a>]</span> each describe exception based mechanisms for unwinding a stack in response to a cancellation request. These mechanisms have all been removed in later paper revisions due to issues with using exceptions to unwind the stack.</p>
<p>The <code>jthread</code> paper also defines <code>stop_source</code> and <code>stop_token</code>. A <code>stop_source</code> allows cancellation to be requested. A callback can be attached to the corresponding <code>stop_token</code> that will be called when the cancellation is requested. The <code>stop_token</code> also has methods to report the current cancellation state.</p>
<p>The <code>stop_source</code>/<code>stop_token</code> mechanism provides a way to request an async function to stop but does not specify how the async function completes without a value or an error. This paper will explore how an async function will complete when it is stopped and why that is not an exception or an error.</p>
<p>The <code>jthread</code> and <code>fiber_token</code> use cases involve unwinding more conventional stack frames. This same functionality is also required in other realms. <span class="citation" data-cites="P1745R0">[<a href="#ref-P1745R0" role="doc-biblioref">P1745R0</a>]</span> describes how to add support for unwinding a graph of coroutine frames without using errors. <span class="citation" data-cites="P1660R0">[<a href="#ref-P1660R0" role="doc-biblioref">P1660R0</a>]</span> describes a solution for unwinding a graph of dependent tasks.</p>
<h1 id="motivation"><span class="header-section-number">4</span> Motivation<a href="#motivation" class="self-link"></a></h1>
<p>Motivations for this paper include previously proposed features (eg. <a href="#stack-unwinding">stack unwinding</a>), existing practice (eg. <a href="#callbacks">Callbacks</a>), and the needs of generic code and algorithms (eg. <a href="#algorithms-that-cancel">Algorithms that cancel</a>).</p>
<h2 id="stack-unwinding"><span class="header-section-number">4.1</span> stack unwinding<a href="#stack-unwinding" class="self-link"></a></h2>
<p><span class="citation" data-cites="P0660R4">[<a href="#ref-P0660R4" role="doc-biblioref">P0660R4</a>]</span> is an earlier revision of the <code>jthread</code> paper that defined a <code>std::interrupted</code> exception and a <code>std::this_thread::throw_if_interrupted()</code> API. These were intended to exit an arbitrary scope using the exception mechanism.</p>
<p>This revision of the paper was discussed in an SG1 meeting in Seattle <a href="http://wiki.edg.com/bin/view/ExecSeattle2018/MinutesDay2">wiki</a>. After several issues were described related to TLS and reporting cancellation as an exception, the participants voted that the parts related to the <code>std::interrupted</code> exception should be removed from the paper.</p>
<p>The <code>fiber_context</code> paper <span class="citation" data-cites="P0876R5">[<a href="#ref-P0876R5" role="doc-biblioref">P0876R5</a>]</span> defined <code>unwind_exception</code>, and after similar discussion in San Diego, <span class="citation" data-cites="P0876R6">[<a href="#ref-P0876R6" role="doc-biblioref">P0876R6</a>]</span> replaced <code>unwind_exception</code> with a ‘platform exception’ that did not run catch blocks. The ‘platform exception’ was removed after more discussion in Cologne.</p>
<p>The issues related to reporting cancellation as a C++ exception included explicitly ignoring <code>std::interrupted</code> and transporting <code>std::interrupted</code>.</p>
<h3 id="c-exception"><span class="header-section-number">4.1.1</span> C++ exception<a href="#c-exception" class="self-link"></a></h3>
<h4 id="explicitly-ignoring-stdinterrupted"><span class="header-section-number">4.1.1.1</span> explicitly ignoring <code>std::interrupted</code><a href="#explicitly-ignoring-stdinterrupted" class="self-link"></a></h4>
<p><span class="citation" data-cites="P0660R4">[<a href="#ref-P0660R4" role="doc-biblioref">P0660R4</a>]</span> added this to <code>std::thread</code>.</p>
<blockquote>
<p>An uncaught interrupted exception in the started thread of execution will silently be ignored. [Note: Thus, an uncaught exception thrown by this_thread::throw_if_interrupted() will cause the started thread to end silently. — end note]</p>
</blockquote>
<p>This is an example of how existing error handling must change when cancellation is reported as an error. <code>std::interrupted</code> requires that, in every function on the stack in the thread, at the time cancellation is reported, the <code>std::interrupted</code> exception is explicitly ignored. <code>std::interrupted</code> was intended to be implicitly ignored, and to help achieve this, <code>std::interrupted</code> was not derived from <code>std::exception</code>. Explicit handling of <code>std::interrupted</code> is still required in that:</p>
<ul>
<li>noexcept functions cannot be on the stack to be unwound</li>
<li>all functions that cross ABI boundaries, such as callbacks passed to C functions, like OS APIs, must suppress <code>std::interrupted</code></li>
<li>all <code>catch(...)</code> must rethrow, just in case the exception is <code>std::interrupted</code></li>
<li>all <code>catch(...)</code> must be called for <code>std::interrupted</code>, since many <code>catch(...)</code> are used to cleanup and some of those instances are in std lib implementations.</li>
<li>all <code>catch(const std::interrupted&amp;)</code> must rethrow.</li>
</ul>
<p>It is interesting to note that the ABI boundary restriction conflicts with the catch restrictions. The ABI and the catch restrictions also led to the second issue.</p>
<h4 id="transporting-stdinterrupted"><span class="header-section-number">4.1.1.2</span> transporting <code>std::interrupted</code><a href="#transporting-stdinterrupted" class="self-link"></a></h4>
<p><code>std::exception_ptr</code> and <code>std::current_exception()</code> were introduced to support async facilities like <code>std::thread</code>, Futures, Executors and Coroutines that must be able to transport exceptions from one thread to another and facilities that transport exceptions across ABI boundaries. While this appears to satisfy the catch restrictions by re-throwing a saved <code>std::exception_ptr</code> on a different thread, this adds even more instances of code that need to be explicitly aware of <code>std::interrupted</code>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" title="1"><span class="dt">void</span> f<span class="op">(</span>MyCallback out<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="cf">try</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb1-3" title="3">    out<span class="op">(</span>g<span class="op">())</span>;</a>
<a class="sourceLine" id="cb1-4" title="4">  <span class="op">}</span></a>
<a class="sourceLine" id="cb1-5" title="5">  <span class="cf">catch</span><span class="op">(...)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb1-6" title="6">    <span class="co">// should std::interrupted be forwarded to out or </span></a>
<a class="sourceLine" id="cb1-7" title="7">    <span class="co">// should it be used to unwind f()?</span></a>
<a class="sourceLine" id="cb1-8" title="8">    out<span class="op">.</span>error<span class="op">(</span>std<span class="op">::</span>current_exception<span class="op">())</span>;</a>
<a class="sourceLine" id="cb1-9" title="9">  <span class="op">}</span></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="op">}</span></a></code></pre></div>
<p>When <code>std::interrupted</code> is transported from thread A to thread B: - was <code>std::interrupted</code> intended to tear down thread A? How is that determined? - does thread B support <code>std::interrupted</code> (it might be an OS thread)? - does every function on the stack in thread B when the exception is re-thrown support <code>std::interrupted</code>?</p>
<h3 id="non-cpp-exception"><span class="header-section-number">4.1.2</span> non-cpp-exception<a href="#non-cpp-exception" class="self-link"></a></h3>
<p>The issues of ignoring and transporting C++ exceptions for unwind has led to alternative designs that involve a non-cpp-exception.</p>
<p>A non-cpp-exception can have different interactions with catch blocks than C++ exceptions. Three of these potential interaction choices are explored here.</p>
<h4 id="non-cpp-exception-that-does-not-execute-catch-blocks"><span class="header-section-number">4.1.2.1</span> non-cpp-exception that does not execute catch blocks<a href="#non-cpp-exception-that-does-not-execute-catch-blocks" class="self-link"></a></h4>
<p>One option is to never run any catch block during unwind. This depends on destructors to do all cleanup and restore all invariants.</p>
<p>Here is an example of code that would not be safe to have on the stack when catch blocks are not executed.</p>
<p><strong>Example:</strong> unlock will not be called on unwind.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="dt">void</span> f<span class="op">(</span>Foo foo<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="cf">try</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-3" title="3">    foo<span class="op">.</span>lock<span class="op">()</span>;</a>
<a class="sourceLine" id="cb2-4" title="4">    g<span class="op">()</span>;</a>
<a class="sourceLine" id="cb2-5" title="5">    foo<span class="op">.</span>unlock<span class="op">()</span>;</a>
<a class="sourceLine" id="cb2-6" title="6">  <span class="op">}</span></a>
<a class="sourceLine" id="cb2-7" title="7">  <span class="cf">catch</span><span class="op">(...)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-8" title="8">    <span class="co">// invariant violation</span></a>
<a class="sourceLine" id="cb2-9" title="9">    foo<span class="op">.</span>unlock<span class="op">()</span>;</a>
<a class="sourceLine" id="cb2-10" title="10">  <span class="op">}</span></a>
<a class="sourceLine" id="cb2-11" title="11"><span class="op">}</span></a></code></pre></div>
<h4 id="non-cpp-exception-that-will-execute-catch-blocks-normally"><span class="header-section-number">4.1.2.2</span> non-cpp-exception that will execute catch(…) blocks normally<a href="#non-cpp-exception-that-will-execute-catch-blocks-normally" class="self-link"></a></h4>
<p>One option is to run each <code>catch(...)</code> block during unwind. This allows <code>catch(...)</code> blocks and destructors to cleanup and restore all invariants.</p>
<p>Here are examples of code that would not be safe to have on the stack when <code>catch(...)</code> blocks are run normally.</p>
<p><strong>Example:</strong> The unwind will be stopped and the result of <code>std::current_exception()</code> would be used even though there is no valid value for it to return.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" title="1"><span class="dt">void</span> f<span class="op">(</span>Foo foo<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb3-2" title="2">  Bar<span class="op">*</span> bar <span class="op">=</span> <span class="kw">nullptr</span>;</a>
<a class="sourceLine" id="cb3-3" title="3">  <span class="cf">try</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb3-4" title="4">    bar <span class="op">=</span> g<span class="op">()</span>;</a>
<a class="sourceLine" id="cb3-5" title="5">  <span class="op">}</span></a>
<a class="sourceLine" id="cb3-6" title="6">  <span class="cf">catch</span><span class="op">(...)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb3-7" title="7">    <span class="co">// what does current_exception() return for non-cpp-exception?</span></a>
<a class="sourceLine" id="cb3-8" title="8">    <span class="co">// what do other exception related functions return?</span></a>
<a class="sourceLine" id="cb3-9" title="9">    foo<span class="op">.</span>error<span class="op">(</span>std<span class="op">::</span>current_exception<span class="op">())</span>;</a>
<a class="sourceLine" id="cb3-10" title="10"></a>
<a class="sourceLine" id="cb3-11" title="11">    <span class="co">// is it ok for this to suppress the non-cpp-exception thus stopping the unwind?</span></a>
<a class="sourceLine" id="cb3-12" title="12">    <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb3-13" title="13">  <span class="op">}</span></a>
<a class="sourceLine" id="cb3-14" title="14">  foo<span class="op">(</span>bar<span class="op">)</span>;</a>
<a class="sourceLine" id="cb3-15" title="15"><span class="op">}</span></a></code></pre></div>
<p><strong>Example:</strong> The unwind would not run the catch and thus would not call unlock.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" title="1"><span class="dt">void</span> f<span class="op">(</span>Foo foo<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb4-2" title="2">  <span class="cf">try</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb4-3" title="3">    foo<span class="op">.</span>lock<span class="op">()</span>;</a>
<a class="sourceLine" id="cb4-4" title="4">    g<span class="op">()</span>;</a>
<a class="sourceLine" id="cb4-5" title="5">    foo<span class="op">.</span>unlock<span class="op">()</span>;</a>
<a class="sourceLine" id="cb4-6" title="6">  <span class="op">}</span></a>
<a class="sourceLine" id="cb4-7" title="7">  <span class="cf">catch</span><span class="op">(</span><span class="kw">const</span> std<span class="op">::</span>exception<span class="op">&amp;)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb4-8" title="8">    <span class="co">// invariant violation</span></a>
<a class="sourceLine" id="cb4-9" title="9">    foo<span class="op">.</span>unlock<span class="op">()</span>;</a>
<a class="sourceLine" id="cb4-10" title="10">  <span class="op">}</span></a>
<a class="sourceLine" id="cb4-11" title="11"><span class="op">}</span></a></code></pre></div>
<h4 id="non-cpp-exception-that-will-execute-catch-blocks-and-force-a-rethrow-at-the-end-of-the-block"><span class="header-section-number">4.1.2.3</span> non-cpp-exception that will execute catch(…) blocks and force a rethrow at the end of the block<a href="#non-cpp-exception-that-will-execute-catch-blocks-and-force-a-rethrow-at-the-end-of-the-block" class="self-link"></a></h4>
<p>One option is to run each <code>catch(...)</code> block during unwind and then unconditionally rethrow at the end of the catch block. This allows <code>catch(...)</code> blocks and destructors to cleanup and restore invariants.</p>
<p>Here are examples of code that would not be safe to have on the stack when <code>catch(...)</code> blocks are run and then forced to rethrow.</p>
<p><strong>Example:</strong> unlock will not be called on unwind.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" title="1"><span class="dt">void</span> f<span class="op">(</span>Foo foo<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb5-2" title="2">  foo<span class="op">.</span>lock<span class="op">()</span>;</a>
<a class="sourceLine" id="cb5-3" title="3">  <span class="cf">try</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb5-4" title="4">    g<span class="op">()</span>;</a>
<a class="sourceLine" id="cb5-5" title="5">  <span class="op">}</span></a>
<a class="sourceLine" id="cb5-6" title="6">  <span class="cf">catch</span><span class="op">(...)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb5-7" title="7">  <span class="op">}</span></a>
<a class="sourceLine" id="cb5-8" title="8">  <span class="co">// invariant violation</span></a>
<a class="sourceLine" id="cb5-9" title="9">  foo<span class="op">.</span>unlock<span class="op">()</span>;</a>
<a class="sourceLine" id="cb5-10" title="10"><span class="op">}</span></a></code></pre></div>
<p><strong>Example:</strong> The result of <code>std::current_exception()</code> would be used even though there is no valid value for it to return. Control-flow choices are ignored.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" title="1"><span class="dt">void</span> f<span class="op">(</span>Foo foo<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb6-2" title="2">  Bar<span class="op">*</span> bar <span class="op">=</span> <span class="kw">nullptr</span>;</a>
<a class="sourceLine" id="cb6-3" title="3">  <span class="cf">try</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb6-4" title="4">    bar <span class="op">=</span> g<span class="op">()</span>;</a>
<a class="sourceLine" id="cb6-5" title="5">  <span class="op">}</span></a>
<a class="sourceLine" id="cb6-6" title="6">  <span class="cf">catch</span><span class="op">(...)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb6-7" title="7">    <span class="co">// what does current_exception() return for non-cpp-exception?</span></a>
<a class="sourceLine" id="cb6-8" title="8">    <span class="co">// what do other exception related functions return?</span></a>
<a class="sourceLine" id="cb6-9" title="9">    foo<span class="op">.</span>error<span class="op">(</span>std<span class="op">::</span>current_exception<span class="op">())</span>;</a>
<a class="sourceLine" id="cb6-10" title="10"></a>
<a class="sourceLine" id="cb6-11" title="11">    <span class="co">// does not skip the rethrow</span></a>
<a class="sourceLine" id="cb6-12" title="12">    <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb6-13" title="13">  <span class="op">}</span></a>
<a class="sourceLine" id="cb6-14" title="14">  foo<span class="op">(</span>bar<span class="op">)</span>;</a>
<a class="sourceLine" id="cb6-15" title="15"><span class="op">}</span></a></code></pre></div>
<p><strong>Example:</strong> The unwind would not run the catch and thus would not call unlock.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb7-1" title="1"><span class="dt">void</span> f<span class="op">(</span>Foo foo<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb7-2" title="2">  <span class="cf">try</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb7-3" title="3">    foo<span class="op">.</span>lock<span class="op">()</span>;</a>
<a class="sourceLine" id="cb7-4" title="4">    g<span class="op">()</span>;</a>
<a class="sourceLine" id="cb7-5" title="5">    foo<span class="op">.</span>unlock<span class="op">()</span>;</a>
<a class="sourceLine" id="cb7-6" title="6">  <span class="op">}</span></a>
<a class="sourceLine" id="cb7-7" title="7">  <span class="cf">catch</span><span class="op">(</span><span class="kw">const</span> std<span class="op">::</span>exception<span class="op">&amp;)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb7-8" title="8">    <span class="co">// invariant violation</span></a>
<a class="sourceLine" id="cb7-9" title="9">    foo<span class="op">.</span>unlock<span class="op">()</span>;</a>
<a class="sourceLine" id="cb7-10" title="10">  <span class="op">}</span></a>
<a class="sourceLine" id="cb7-11" title="11"><span class="op">}</span></a></code></pre></div>
<h2 id="algorithms-that-cancel"><span class="header-section-number">4.2</span> Algorithms that cancel<a href="#algorithms-that-cancel" class="self-link"></a></h2>
<p>There are many algorithms for async functions. These algorithms must be able to trigger cancellation and stop cleanly when cancelled.</p>
<p>Some examples:</p>
<ul>
<li>the <code>when_any()</code> (aka <code>amb()</code>) algorithm which cancels the other producers once one of them produced a value (and in this case, emits no error).</li>
<li>the <code>when_all()</code> (aka <code>zip()</code>) algorithm which cancels the other producers when one completes with an error.</li>
<li>the <code>take_until()</code> algorithm which cancels the source when thetrigger completes and cancels the trigger when the source completes.</li>
<li>the <code>timeout()</code> algorithm which cancels the source when it does not produce a value before the timeout and then emits <code>timeout_error</code> (which is defined as part of the <code>timeout()</code> algorithm).</li>
</ul>
<h3 id="when_any"><span class="header-section-number">4.2.1</span> <code>when_any()</code><a href="#when_any" class="self-link"></a></h3>
<p>One expression of the <code>when_any()</code> algorithm takes a set of async functions that have a common return type and returns the result of the first async function to complete with a value or error and cancels the rest and emits the value or error.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb8-1" title="1"><span class="dt">void</span> foo<span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb8-2" title="2">  common_type_t<span class="op">&lt;</span>invoke_result_t<span class="op">&lt;</span>f<span class="op">&gt;</span>, invoke_result_t<span class="op">&lt;</span>g<span class="op">&gt;&gt;</span> v <span class="op">=</span> wait<span class="op">(</span>when_any<span class="op">(</span>f, g<span class="op">))</span>;</a>
<a class="sourceLine" id="cb8-3" title="3">  <span class="co">// ..</span></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="op">}</span></a></code></pre></div>
<p><code>when_any()</code> must have a way to know when an async function completed. <code>when_any()</code> is interested in knowing when an async function has completed with a value, with an error and with serendipitous-success. When all the async functions complete with serendipitous-success, then <code>when_any()</code> must complete with serendipitous-success.</p>
<blockquote>
<p>NOTE: For the purpose of comparison this paper will use the Callback naming specified in <span class="citation" data-cites="P1660R0">[<a href="#ref-P1660R0" role="doc-biblioref">P1660R0</a>]</span> as an example of <a href="#multiple-function-style">multiple function style</a>. The names chosen for a particular expression of the <a href="#multiple-function-style">multiple function style</a> do not affect this proposal.</p>
</blockquote>
<table>
<caption>generic <code>when_any()</code> algorithm example (simplified for clarity)</caption>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>function</strong>
</div></th>
<th><div style="text-align:center">
<strong>pipe operator</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">namespace</span> when_any_alg <span class="op">{</span></a>
<a class="sourceLine" id="cb9-2" title="2"></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> C<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb9-4" title="4"><span class="kw">struct</span> result <span class="op">{</span></a>
<a class="sourceLine" id="cb9-5" title="5">  C c_;</a>
<a class="sourceLine" id="cb9-6" title="6">  atomic<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> remain_ <span class="op">=</span> <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb9-7" title="7">  function<span class="op">&lt;</span><span class="dt">void</span><span class="op">(</span>C<span class="op">)&gt;</span> r_;</a>
<a class="sourceLine" id="cb9-8" title="8">  stop_source stop_;</a>
<a class="sourceLine" id="cb9-9" title="9">  <span class="dt">void</span> defer<span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb9-10" title="10">    <span class="cf">if</span> <span class="op">(--</span>remain_ <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb9-11" title="11">      <span class="cf">if</span> <span class="op">(!</span>r_<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb9-12" title="12">        c_<span class="op">.</span>done<span class="op">()</span>;</a>
<a class="sourceLine" id="cb9-13" title="13">      <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb9-14" title="14">        r_<span class="op">(</span>c_<span class="op">)</span>;</a>
<a class="sourceLine" id="cb9-15" title="15">      <span class="op">}</span></a>
<a class="sourceLine" id="cb9-16" title="16">    <span class="op">}</span></a>
<a class="sourceLine" id="cb9-17" title="17">  <span class="op">}</span></a>
<a class="sourceLine" id="cb9-18" title="18"><span class="op">}</span>;</a></code></pre></div></td>
<td><div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">namespace</span> when_any_alg <span class="op">{</span></a>
<a class="sourceLine" id="cb10-2" title="2"></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> C<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb10-4" title="4"><span class="kw">struct</span> result <span class="op">{</span></a>
<a class="sourceLine" id="cb10-5" title="5">  C c_;</a>
<a class="sourceLine" id="cb10-6" title="6">  atomic<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> remain_ <span class="op">=</span> <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb10-7" title="7">  function<span class="op">&lt;</span><span class="dt">void</span><span class="op">(</span>C<span class="op">)&gt;</span> r_;</a>
<a class="sourceLine" id="cb10-8" title="8">  stop_source stop_;</a>
<a class="sourceLine" id="cb10-9" title="9">  <span class="dt">void</span> defer<span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb10-10" title="10">    <span class="cf">if</span> <span class="op">(--</span>remain_ <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb10-11" title="11">      <span class="cf">if</span> <span class="op">(!</span>r_<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb10-12" title="12">        c_<span class="op">.</span>done<span class="op">()</span>;</a>
<a class="sourceLine" id="cb10-13" title="13">      <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb10-14" title="14">        r_<span class="op">(</span>c_<span class="op">)</span>;</a>
<a class="sourceLine" id="cb10-15" title="15">      <span class="op">}</span></a>
<a class="sourceLine" id="cb10-16" title="16">    <span class="op">}</span></a>
<a class="sourceLine" id="cb10-17" title="17">  <span class="op">}</span></a>
<a class="sourceLine" id="cb10-18" title="18"><span class="op">}</span>;</a></code></pre></div></td>
</tr>
<tr class="even">
<td><div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> R<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb11-2" title="2"><span class="kw">struct</span> when_any_callback <span class="op">{</span></a>
<a class="sourceLine" id="cb11-3" title="3">  R r_;</a>
<a class="sourceLine" id="cb11-4" title="4">  <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span><span class="kw">auto</span><span class="op">...</span> vn<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb11-5" title="5">    <span class="cf">if</span> <span class="op">(</span>stop_<span class="op">.</span>request_stop<span class="op">())</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb11-6" title="6">      r_<span class="op">-&gt;</span>r_ <span class="op">=</span> <span class="op">[</span>t<span class="op">=</span>make_tuple<span class="op">(</span>vn<span class="op">...)]</span> </a>
<a class="sourceLine" id="cb11-7" title="7">        <span class="op">(</span><span class="kw">auto</span> c<span class="op">)</span> <span class="op">{</span>apply<span class="op">(</span>c, t<span class="op">)</span>;<span class="op">}</span>;</a>
<a class="sourceLine" id="cb11-8" title="8">    <span class="op">}</span></a>
<a class="sourceLine" id="cb11-9" title="9">    r_<span class="op">-&gt;</span>defer<span class="op">()</span>;</a>
<a class="sourceLine" id="cb11-10" title="10">  <span class="op">}</span></a>
<a class="sourceLine" id="cb11-11" title="11">  <span class="dt">void</span> error<span class="op">(</span><span class="kw">auto</span> e<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb11-12" title="12">    <span class="cf">if</span> <span class="op">(</span>stop_<span class="op">.</span>request_stop<span class="op">())</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb11-13" title="13">      r_<span class="op">-&gt;</span>r_ <span class="op">=</span> <span class="op">[</span>e<span class="op">]</span> </a>
<a class="sourceLine" id="cb11-14" title="14">        <span class="op">(</span><span class="kw">auto</span> c<span class="op">)</span> <span class="op">{</span>c<span class="op">.</span>error<span class="op">(</span>e<span class="op">)</span>;<span class="op">}</span>;</a>
<a class="sourceLine" id="cb11-15" title="15">    <span class="op">}</span></a>
<a class="sourceLine" id="cb11-16" title="16">    r_<span class="op">-&gt;</span>defer<span class="op">()</span>;</a>
<a class="sourceLine" id="cb11-17" title="17">  <span class="op">}</span></a>
<a class="sourceLine" id="cb11-18" title="18">  <span class="dt">void</span> done<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb11-19" title="19">    r_<span class="op">-&gt;</span>defer<span class="op">()</span>;</a>
<a class="sourceLine" id="cb11-20" title="20">  <span class="op">}</span></a>
<a class="sourceLine" id="cb11-21" title="21"><span class="op">}</span>;</a></code></pre></div></td>
<td><div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> R<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb12-2" title="2"><span class="kw">struct</span> when_any_callback <span class="op">{</span></a>
<a class="sourceLine" id="cb12-3" title="3">  R r_;</a>
<a class="sourceLine" id="cb12-4" title="4">  <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span><span class="kw">auto</span><span class="op">...</span> vn<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb12-5" title="5">    <span class="cf">if</span> <span class="op">(</span>stop_<span class="op">.</span>request_stop<span class="op">())</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb12-6" title="6">      r_<span class="op">-&gt;</span>r_ <span class="op">=</span> <span class="op">[</span>t<span class="op">=</span>make_tuple<span class="op">(</span>vn<span class="op">...)]</span> </a>
<a class="sourceLine" id="cb12-7" title="7">        <span class="op">(</span><span class="kw">auto</span> c<span class="op">)</span> <span class="op">{</span>apply<span class="op">(</span>c, t<span class="op">)</span>;<span class="op">}</span>;</a>
<a class="sourceLine" id="cb12-8" title="8">    <span class="op">}</span></a>
<a class="sourceLine" id="cb12-9" title="9">    r_<span class="op">-&gt;</span>defer<span class="op">()</span>;</a>
<a class="sourceLine" id="cb12-10" title="10">  <span class="op">}</span></a>
<a class="sourceLine" id="cb12-11" title="11">  <span class="dt">void</span> error<span class="op">(</span><span class="kw">auto</span> e<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb12-12" title="12">    <span class="cf">if</span> <span class="op">(</span>stop_<span class="op">.</span>request_stop<span class="op">())</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb12-13" title="13">      r_<span class="op">-&gt;</span>r_ <span class="op">=</span> <span class="op">[</span>e<span class="op">]</span> </a>
<a class="sourceLine" id="cb12-14" title="14">        <span class="op">(</span><span class="kw">auto</span> c<span class="op">)</span> <span class="op">{</span>c<span class="op">.</span>error<span class="op">(</span>e<span class="op">)</span>;<span class="op">}</span>;</a>
<a class="sourceLine" id="cb12-15" title="15">    <span class="op">}</span></a>
<a class="sourceLine" id="cb12-16" title="16">    r_<span class="op">-&gt;</span>defer<span class="op">()</span>;</a>
<a class="sourceLine" id="cb12-17" title="17">  <span class="op">}</span></a>
<a class="sourceLine" id="cb12-18" title="18">  <span class="dt">void</span> done<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb12-19" title="19">    r_<span class="op">-&gt;</span>defer<span class="op">()</span>;</a>
<a class="sourceLine" id="cb12-20" title="20">  <span class="op">}</span></a>
<a class="sourceLine" id="cb12-21" title="21"><span class="op">}</span>;</a></code></pre></div></td>
</tr>
<tr class="odd">
<td><div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> S0, <span class="kw">class</span> S1<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb13-2" title="2"><span class="kw">struct</span> when_any_sender <span class="op">{</span></a>
<a class="sourceLine" id="cb13-3" title="3">  S0 s0_;</a>
<a class="sourceLine" id="cb13-4" title="4">  S1 s1_;</a>
<a class="sourceLine" id="cb13-5" title="5">  <span class="dt">void</span> submit<span class="op">(</span>Callback <span class="kw">auto</span> c<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb13-6" title="6">    <span class="kw">auto</span> r <span class="op">=</span> make_shared<span class="op">&lt;</span></a>
<a class="sourceLine" id="cb13-7" title="7">      result<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>c<span class="op">)&gt;{</span>c<span class="op">}</span>;</a>
<a class="sourceLine" id="cb13-8" title="8">    s0_<span class="op">.</span>submit<span class="op">(</span></a>
<a class="sourceLine" id="cb13-9" title="9">      when_any_callback<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>r<span class="op">)&gt;{</span></a>
<a class="sourceLine" id="cb13-10" title="10">        r<span class="op">})</span>;</a>
<a class="sourceLine" id="cb13-11" title="11">    s1_<span class="op">.</span>submit<span class="op">(</span></a>
<a class="sourceLine" id="cb13-12" title="12">      when_any_callback<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>r<span class="op">)&gt;{</span></a>
<a class="sourceLine" id="cb13-13" title="13">        r<span class="op">})</span>;</a>
<a class="sourceLine" id="cb13-14" title="14">  <span class="op">}</span></a>
<a class="sourceLine" id="cb13-15" title="15"><span class="op">}</span>;</a></code></pre></div></td>
<td><div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> S0, <span class="kw">class</span> S1<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb14-2" title="2"><span class="kw">struct</span> when_any_sender <span class="op">{</span></a>
<a class="sourceLine" id="cb14-3" title="3">  S0 s0_;</a>
<a class="sourceLine" id="cb14-4" title="4">  S1 s1_;</a>
<a class="sourceLine" id="cb14-5" title="5">  <span class="dt">void</span> submit<span class="op">(</span>Callback <span class="kw">auto</span> c<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb14-6" title="6">    <span class="kw">auto</span> r <span class="op">=</span> make_shared<span class="op">&lt;</span></a>
<a class="sourceLine" id="cb14-7" title="7">      result<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>c<span class="op">)&gt;{</span>c<span class="op">}</span>;</a>
<a class="sourceLine" id="cb14-8" title="8">    s0_<span class="op">.</span>submit<span class="op">(</span></a>
<a class="sourceLine" id="cb14-9" title="9">      when_any_callback<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>r<span class="op">)&gt;{</span></a>
<a class="sourceLine" id="cb14-10" title="10">        r<span class="op">})</span>;</a>
<a class="sourceLine" id="cb14-11" title="11">    s1_<span class="op">.</span>submit<span class="op">(</span></a>
<a class="sourceLine" id="cb14-12" title="12">      when_any_callback<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>r<span class="op">)&gt;{</span></a>
<a class="sourceLine" id="cb14-13" title="13">        r<span class="op">})</span>;</a>
<a class="sourceLine" id="cb14-14" title="14">  <span class="op">}</span></a>
<a class="sourceLine" id="cb14-15" title="15"><span class="op">}</span>;</a></code></pre></div></td>
</tr>
<tr class="even">
<td><div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">struct</span> fn <span class="op">{</span></a>
<a class="sourceLine" id="cb15-2" title="2">  <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()(</span></a>
<a class="sourceLine" id="cb15-3" title="3">    Sender <span class="kw">auto</span> s0, Sender <span class="kw">auto</span> s1<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb15-4" title="4">    <span class="cf">return</span> when_any_sender<span class="op">&lt;</span></a>
<a class="sourceLine" id="cb15-5" title="5">      <span class="kw">decltype</span><span class="op">(</span>s0<span class="op">)</span>, <span class="kw">decltype</span><span class="op">(</span>s1<span class="op">)&gt;{</span>s0, s1<span class="op">}</span>;</a>
<a class="sourceLine" id="cb15-6" title="6">  <span class="op">}</span></a>
<a class="sourceLine" id="cb15-7" title="7"><span class="op">}</span>;</a>
<a class="sourceLine" id="cb15-8" title="8"></a>
<a class="sourceLine" id="cb15-9" title="9"><span class="op">}</span></a>
<a class="sourceLine" id="cb15-10" title="10"><span class="kw">constexpr</span> <span class="kw">inline</span> when_any_alg<span class="op">::</span>fn when_any<span class="op">{}</span>;</a></code></pre></div></td>
<td><div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> S1<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb16-2" title="2"><span class="kw">struct</span> pipe_fn <span class="op">{</span></a>
<a class="sourceLine" id="cb16-3" title="3">  S1 s1_;</a>
<a class="sourceLine" id="cb16-4" title="4">  <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()(</span>Sender <span class="kw">auto</span> s0<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb16-5" title="5">    <span class="cf">return</span> when_any_sender<span class="op">&lt;</span></a>
<a class="sourceLine" id="cb16-6" title="6">      <span class="kw">decltype</span><span class="op">(</span>s0<span class="op">)</span>, S1<span class="op">&gt;{</span>s0, s1_<span class="op">}</span>;</a>
<a class="sourceLine" id="cb16-7" title="7">  <span class="op">}</span></a>
<a class="sourceLine" id="cb16-8" title="8"><span class="op">}</span>;</a>
<a class="sourceLine" id="cb16-9" title="9"></a>
<a class="sourceLine" id="cb16-10" title="10"><span class="kw">struct</span> fn <span class="op">{</span></a>
<a class="sourceLine" id="cb16-11" title="11">  <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()(</span>Sender <span class="kw">auto</span> s1<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb16-12" title="12">    <span class="cf">return</span> pipe_fn<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>s1<span class="op">)&gt;{</span>s1<span class="op">}</span>;</a>
<a class="sourceLine" id="cb16-13" title="13">  <span class="op">}</span></a>
<a class="sourceLine" id="cb16-14" title="14"><span class="op">}</span>;</a>
<a class="sourceLine" id="cb16-15" title="15"></a>
<a class="sourceLine" id="cb16-16" title="16"><span class="op">}</span></a>
<a class="sourceLine" id="cb16-17" title="17"><span class="kw">constexpr</span> <span class="kw">inline</span> when_any_alg<span class="op">::</span>fn when_any<span class="op">{}</span>;</a></code></pre></div></td>
</tr>
</tbody>
</table>
<p>When some errors are supposed to terminate the operation early and others are not supposed to terminate the operation early, then an additional predicate is needed to select when to terminate early. If S0 calls <code>error()</code> with <code>cancelled_error</code> then S1 may still complete with a value. If S0 completes with <code>timeout_error</code> then it does not matter what S1 will complete with.</p>
<table>
<caption>generic <code>when_any()</code> algorithm example - <code>done()</code> vs. inspect <code>error()</code></caption>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong><code>done()</code></strong>
</div></th>
<th><div style="text-align:center">
<strong>inspect <code>error()</code></strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">namespace</span> when_any_alg <span class="op">{</span></a>
<a class="sourceLine" id="cb17-2" title="2"></a>
<a class="sourceLine" id="cb17-3" title="3"></a>
<a class="sourceLine" id="cb17-4" title="4"></a>
<a class="sourceLine" id="cb17-5" title="5"><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> C<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb17-6" title="6"><span class="kw">struct</span> result <span class="op">{</span></a>
<a class="sourceLine" id="cb17-7" title="7"></a>
<a class="sourceLine" id="cb17-8" title="8">  C c_;</a>
<a class="sourceLine" id="cb17-9" title="9">  atomic<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> remain_ <span class="op">=</span> <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb17-10" title="10">  function<span class="op">&lt;</span><span class="dt">void</span><span class="op">(</span>C<span class="op">)&gt;</span> r_;</a>
<a class="sourceLine" id="cb17-11" title="11">  stop_source stop_;</a>
<a class="sourceLine" id="cb17-12" title="12">  <span class="dt">void</span> defer<span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb17-13" title="13">    <span class="cf">if</span> <span class="op">(--</span>remain_ <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb17-14" title="14">      <span class="cf">if</span> <span class="op">(!</span>r_<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb17-15" title="15">        c_<span class="op">.</span>done<span class="op">()</span>;</a>
<a class="sourceLine" id="cb17-16" title="16">      <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb17-17" title="17">        r_<span class="op">(</span>c_<span class="op">)</span>;</a>
<a class="sourceLine" id="cb17-18" title="18">      <span class="op">}</span></a>
<a class="sourceLine" id="cb17-19" title="19">    <span class="op">}</span></a>
<a class="sourceLine" id="cb17-20" title="20">  <span class="op">}</span></a>
<a class="sourceLine" id="cb17-21" title="21"><span class="op">}</span>;</a></code></pre></div></td>
<td><div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">namespace</span> when_any_alg <span class="op">{</span></a>
<a class="sourceLine" id="cb18-2" title="2"></a>
<a class="sourceLine" id="cb18-3" title="3"><span class="kw">struct</span> when_any_stopped <span class="op">{</span></a>
<a class="sourceLine" id="cb18-4" title="4"><span class="op">}</span>;</a>
<a class="sourceLine" id="cb18-5" title="5"><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> P, <span class="kw">class</span> C<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb18-6" title="6"><span class="kw">struct</span> result <span class="op">{</span></a>
<a class="sourceLine" id="cb18-7" title="7">  P p_;</a>
<a class="sourceLine" id="cb18-8" title="8">  C c_;</a>
<a class="sourceLine" id="cb18-9" title="9">  atomic<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> remain_ <span class="op">=</span> <span class="dv">2</span>;</a>
<a class="sourceLine" id="cb18-10" title="10">  function<span class="op">&lt;</span><span class="dt">void</span><span class="op">(</span>C<span class="op">)&gt;</span> r_;</a>
<a class="sourceLine" id="cb18-11" title="11">  stop_source stop_;</a>
<a class="sourceLine" id="cb18-12" title="12">  <span class="dt">void</span> defer<span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb18-13" title="13">    <span class="cf">if</span> <span class="op">(--</span>remain_ <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb18-14" title="14">      <span class="cf">if</span> <span class="op">(!</span>r_<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb18-15" title="15">        c_<span class="op">.</span>error<span class="op">(</span>when_any_stopped<span class="op">{})</span>;</a>
<a class="sourceLine" id="cb18-16" title="16">      <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb18-17" title="17">        r_<span class="op">(</span>c_<span class="op">)</span>;</a>
<a class="sourceLine" id="cb18-18" title="18">      <span class="op">}</span></a>
<a class="sourceLine" id="cb18-19" title="19">    <span class="op">}</span></a>
<a class="sourceLine" id="cb18-20" title="20">  <span class="op">}</span></a>
<a class="sourceLine" id="cb18-21" title="21"><span class="op">}</span>;</a></code></pre></div></td>
</tr>
<tr class="even">
<td><div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb19-1" title="1"><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> R<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb19-2" title="2"><span class="kw">struct</span> when_any_callback <span class="op">{</span></a>
<a class="sourceLine" id="cb19-3" title="3">  R r_;</a>
<a class="sourceLine" id="cb19-4" title="4">  <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span><span class="kw">auto</span><span class="op">...</span> vn<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb19-5" title="5">    <span class="cf">if</span> <span class="op">(</span>stop_<span class="op">.</span>request_stop<span class="op">())</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb19-6" title="6">      r_<span class="op">-&gt;</span>r_ <span class="op">=</span> <span class="op">[</span>t<span class="op">=</span>make_tuple<span class="op">(</span>vn<span class="op">...)]</span> </a>
<a class="sourceLine" id="cb19-7" title="7">        <span class="op">(</span><span class="kw">auto</span> c<span class="op">)</span> <span class="op">{</span>apply<span class="op">(</span>c, t<span class="op">)</span>;<span class="op">}</span>;</a>
<a class="sourceLine" id="cb19-8" title="8">    <span class="op">}</span></a>
<a class="sourceLine" id="cb19-9" title="9">    r_<span class="op">-&gt;</span>defer<span class="op">()</span>;</a>
<a class="sourceLine" id="cb19-10" title="10">  <span class="op">}</span></a>
<a class="sourceLine" id="cb19-11" title="11">  <span class="dt">void</span> error<span class="op">(</span><span class="kw">auto</span> e<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb19-12" title="12"></a>
<a class="sourceLine" id="cb19-13" title="13">    <span class="cf">if</span> <span class="op">(</span>stop_<span class="op">.</span>request_stop<span class="op">())</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb19-14" title="14">      r_<span class="op">-&gt;</span>r_ <span class="op">=</span> <span class="op">[</span>e<span class="op">]</span> </a>
<a class="sourceLine" id="cb19-15" title="15">        <span class="op">(</span><span class="kw">auto</span> c<span class="op">)</span> <span class="op">{</span>c<span class="op">.</span>error<span class="op">(</span>e<span class="op">)</span>;<span class="op">}</span>;</a>
<a class="sourceLine" id="cb19-16" title="16">    <span class="op">}</span></a>
<a class="sourceLine" id="cb19-17" title="17"></a>
<a class="sourceLine" id="cb19-18" title="18">    r_<span class="op">-&gt;</span>defer<span class="op">()</span>;</a>
<a class="sourceLine" id="cb19-19" title="19">  <span class="op">}</span></a>
<a class="sourceLine" id="cb19-20" title="20">  <span class="dt">void</span> done<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb19-21" title="21">    r_<span class="op">-&gt;</span>defer<span class="op">()</span>;</a>
<a class="sourceLine" id="cb19-22" title="22">  <span class="op">}</span></a>
<a class="sourceLine" id="cb19-23" title="23"><span class="op">}</span>;</a></code></pre></div></td>
<td><div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> R<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb20-2" title="2"><span class="kw">struct</span> when_any_callback <span class="op">{</span></a>
<a class="sourceLine" id="cb20-3" title="3">  R r_;</a>
<a class="sourceLine" id="cb20-4" title="4">  <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span><span class="kw">auto</span><span class="op">...</span> vn<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb20-5" title="5">    <span class="cf">if</span> <span class="op">(</span>stop_<span class="op">.</span>request_stop<span class="op">())</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb20-6" title="6">      r_<span class="op">-&gt;</span>r_ <span class="op">=</span> <span class="op">[</span>t<span class="op">=</span>make_tuple<span class="op">(</span>vn<span class="op">...)]</span> </a>
<a class="sourceLine" id="cb20-7" title="7">        <span class="op">(</span><span class="kw">auto</span> c<span class="op">)</span> <span class="op">{</span>apply<span class="op">(</span>c, t<span class="op">)</span>;<span class="op">}</span>;</a>
<a class="sourceLine" id="cb20-8" title="8">    <span class="op">}</span></a>
<a class="sourceLine" id="cb20-9" title="9">    r_<span class="op">-&gt;</span>defer<span class="op">()</span>;</a>
<a class="sourceLine" id="cb20-10" title="10">  <span class="op">}</span></a>
<a class="sourceLine" id="cb20-11" title="11">  <span class="dt">void</span> error<span class="op">(</span><span class="kw">auto</span> e<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb20-12" title="12">    <span class="cf">if</span> <span class="op">(</span>r_<span class="op">-&gt;</span>p_<span class="op">(</span>e<span class="op">))</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb20-13" title="13">      <span class="cf">if</span> <span class="op">(</span>stop_<span class="op">.</span>request_stop<span class="op">())</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb20-14" title="14">        r_<span class="op">-&gt;</span>r_ <span class="op">=</span> <span class="op">[</span>e<span class="op">]</span> </a>
<a class="sourceLine" id="cb20-15" title="15">          <span class="op">(</span><span class="kw">auto</span> c<span class="op">)</span> <span class="op">{</span>c<span class="op">.</span>error<span class="op">(</span>e<span class="op">)</span>;<span class="op">}</span>;</a>
<a class="sourceLine" id="cb20-16" title="16">      <span class="op">}</span></a>
<a class="sourceLine" id="cb20-17" title="17">    <span class="op">}</span></a>
<a class="sourceLine" id="cb20-18" title="18">    r_<span class="op">-&gt;</span>defer<span class="op">()</span>;</a>
<a class="sourceLine" id="cb20-19" title="19">  <span class="op">}</span></a>
<a class="sourceLine" id="cb20-20" title="20"></a>
<a class="sourceLine" id="cb20-21" title="21"></a>
<a class="sourceLine" id="cb20-22" title="22"></a>
<a class="sourceLine" id="cb20-23" title="23"><span class="op">}</span>;</a></code></pre></div></td>
</tr>
<tr class="odd">
<td><div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb21-1" title="1"><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> S0, <span class="kw">class</span> S1<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb21-2" title="2"><span class="kw">struct</span> when_any_sender <span class="op">{</span></a>
<a class="sourceLine" id="cb21-3" title="3"></a>
<a class="sourceLine" id="cb21-4" title="4">  S0 s0_;</a>
<a class="sourceLine" id="cb21-5" title="5">  S1 s1_;</a>
<a class="sourceLine" id="cb21-6" title="6">  <span class="dt">void</span> submit<span class="op">(</span>Callback <span class="kw">auto</span> c<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb21-7" title="7">    <span class="kw">auto</span> r <span class="op">=</span> make_shared<span class="op">&lt;</span></a>
<a class="sourceLine" id="cb21-8" title="8">      result<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>c<span class="op">)&gt;{</span>c<span class="op">}</span>;</a>
<a class="sourceLine" id="cb21-9" title="9">    s0_<span class="op">.</span>submit<span class="op">(</span></a>
<a class="sourceLine" id="cb21-10" title="10">      when_any_callback<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>r<span class="op">)&gt;{</span></a>
<a class="sourceLine" id="cb21-11" title="11">        r<span class="op">})</span>;</a>
<a class="sourceLine" id="cb21-12" title="12">    s1_<span class="op">.</span>submit<span class="op">(</span></a>
<a class="sourceLine" id="cb21-13" title="13">      when_any_callback<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>r<span class="op">)&gt;{</span></a>
<a class="sourceLine" id="cb21-14" title="14">        r<span class="op">})</span>;</a>
<a class="sourceLine" id="cb21-15" title="15">  <span class="op">}</span></a>
<a class="sourceLine" id="cb21-16" title="16"><span class="op">}</span>;</a></code></pre></div></td>
<td><div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> P, <span class="kw">class</span> S0, <span class="kw">class</span> S1<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb22-2" title="2"><span class="kw">struct</span> when_any_sender <span class="op">{</span></a>
<a class="sourceLine" id="cb22-3" title="3">  P p_;</a>
<a class="sourceLine" id="cb22-4" title="4">  S0 s0_;</a>
<a class="sourceLine" id="cb22-5" title="5">  S1 s1_;</a>
<a class="sourceLine" id="cb22-6" title="6">  <span class="dt">void</span> submit<span class="op">(</span>Callback <span class="kw">auto</span> c<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb22-7" title="7">    <span class="kw">auto</span> r <span class="op">=</span> make_shared<span class="op">&lt;</span></a>
<a class="sourceLine" id="cb22-8" title="8">      result<span class="op">&lt;</span>P, <span class="kw">decltype</span><span class="op">(</span>c<span class="op">)&gt;{</span>p_, c<span class="op">}</span>;</a>
<a class="sourceLine" id="cb22-9" title="9">    s0_<span class="op">.</span>submit<span class="op">(</span></a>
<a class="sourceLine" id="cb22-10" title="10">      when_any_callback<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>r<span class="op">)&gt;{</span></a>
<a class="sourceLine" id="cb22-11" title="11">        r<span class="op">})</span>;</a>
<a class="sourceLine" id="cb22-12" title="12">    s1_<span class="op">.</span>submit<span class="op">(</span></a>
<a class="sourceLine" id="cb22-13" title="13">      when_any_callback<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>r<span class="op">)&gt;{</span></a>
<a class="sourceLine" id="cb22-14" title="14">        r<span class="op">})</span>;</a>
<a class="sourceLine" id="cb22-15" title="15">  <span class="op">}</span></a>
<a class="sourceLine" id="cb22-16" title="16"><span class="op">}</span>;</a></code></pre></div></td>
</tr>
<tr class="even">
<td><div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb23-1" title="1"><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> S1<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb23-2" title="2"><span class="kw">struct</span> pipe_fn <span class="op">{</span></a>
<a class="sourceLine" id="cb23-3" title="3"></a>
<a class="sourceLine" id="cb23-4" title="4">  S1 s1_;</a>
<a class="sourceLine" id="cb23-5" title="5">  <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()(</span>Sender <span class="kw">auto</span> s0<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb23-6" title="6">    <span class="cf">return</span> when_any_sender<span class="op">&lt;</span></a>
<a class="sourceLine" id="cb23-7" title="7">      <span class="kw">decltype</span><span class="op">(</span>s0<span class="op">)</span>, S1<span class="op">&gt;{</span>s0, s1_<span class="op">}</span>;</a>
<a class="sourceLine" id="cb23-8" title="8">  <span class="op">}</span></a>
<a class="sourceLine" id="cb23-9" title="9"><span class="op">}</span>;</a>
<a class="sourceLine" id="cb23-10" title="10"></a>
<a class="sourceLine" id="cb23-11" title="11"><span class="kw">struct</span> fn <span class="op">{</span></a>
<a class="sourceLine" id="cb23-12" title="12"></a>
<a class="sourceLine" id="cb23-13" title="13">  <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()(</span>Sender <span class="kw">auto</span> s1<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb23-14" title="14">    <span class="cf">return</span> pipe_fn<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>s1<span class="op">)&gt;{</span>s1<span class="op">}</span>;</a>
<a class="sourceLine" id="cb23-15" title="15">  <span class="op">}</span></a>
<a class="sourceLine" id="cb23-16" title="16"><span class="op">}</span>;</a>
<a class="sourceLine" id="cb23-17" title="17"></a>
<a class="sourceLine" id="cb23-18" title="18"><span class="op">}</span></a>
<a class="sourceLine" id="cb23-19" title="19"><span class="kw">constexpr</span> <span class="kw">inline</span> when_any_alg<span class="op">::</span>fn when_any<span class="op">{}</span>;</a></code></pre></div></td>
<td><div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb24-1" title="1"><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> P, <span class="kw">class</span> S1<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb24-2" title="2"><span class="kw">struct</span> pipe_fn <span class="op">{</span></a>
<a class="sourceLine" id="cb24-3" title="3">  P p_;</a>
<a class="sourceLine" id="cb24-4" title="4">  S1 s1_;</a>
<a class="sourceLine" id="cb24-5" title="5">  <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()(</span>Sender <span class="kw">auto</span> s0<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb24-6" title="6">    <span class="cf">return</span> when_any_sender<span class="op">&lt;</span></a>
<a class="sourceLine" id="cb24-7" title="7">      P, <span class="kw">decltype</span><span class="op">(</span>s0<span class="op">)</span>, S1<span class="op">&gt;{</span>p_, s0, s1_<span class="op">}</span>;</a>
<a class="sourceLine" id="cb24-8" title="8">  <span class="op">}</span></a>
<a class="sourceLine" id="cb24-9" title="9"><span class="op">}</span>;</a>
<a class="sourceLine" id="cb24-10" title="10"></a>
<a class="sourceLine" id="cb24-11" title="11"><span class="kw">struct</span> fn <span class="op">{</span></a>
<a class="sourceLine" id="cb24-12" title="12">  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> P<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb24-13" title="13">  <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()(</span>P p, Sender <span class="kw">auto</span> s1<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb24-14" title="14">    <span class="cf">return</span> pipe_fn<span class="op">&lt;</span>P, <span class="kw">decltype</span><span class="op">(</span>s1<span class="op">)&gt;{</span>p, s1<span class="op">}</span>;</a>
<a class="sourceLine" id="cb24-15" title="15">  <span class="op">}</span></a>
<a class="sourceLine" id="cb24-16" title="16"><span class="op">}</span>;</a>
<a class="sourceLine" id="cb24-17" title="17"></a>
<a class="sourceLine" id="cb24-18" title="18"><span class="op">}</span></a>
<a class="sourceLine" id="cb24-19" title="19"><span class="kw">constexpr</span> <span class="kw">inline</span> when_any_alg<span class="op">::</span>fn when_any<span class="op">{}</span>;</a></code></pre></div></td>
</tr>
</tbody>
</table>
<p>The additional complexity of the predicate impacts each algorithm that cancels. The complexity also impacts each use of algorithms that cancel.</p>
<p>A predicate that filters the errors would have some essential complexity and overhead.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb25-1" title="1"><span class="kw">struct</span> should_fail <span class="op">{</span></a>
<a class="sourceLine" id="cb25-2" title="2">  <span class="dt">bool</span> <span class="kw">operator</span><span class="op">()(</span>std<span class="op">::</span>error_code e<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb25-3" title="3">   <span class="co">//..</span></a>
<a class="sourceLine" id="cb25-4" title="4">  <span class="op">}</span></a>
<a class="sourceLine" id="cb25-5" title="5">  <span class="dt">bool</span> <span class="kw">operator</span><span class="op">()(</span>std<span class="op">::</span>exception_ptr e<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb25-6" title="6">    <span class="cf">try</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb25-7" title="7">      std<span class="op">::</span>rethrow_exception<span class="op">(</span>e<span class="op">)</span>;</a>
<a class="sourceLine" id="cb25-8" title="8">    <span class="op">}</span> <span class="co">// support for specific exceptions..</span></a>
<a class="sourceLine" id="cb25-9" title="9">    <span class="cf">catch</span><span class="op">(...)</span> <span class="op">{</span> <span class="co">// default to failure</span></a>
<a class="sourceLine" id="cb25-10" title="10">      <span class="cf">return</span> <span class="kw">true</span>;</a>
<a class="sourceLine" id="cb25-11" title="11">    <span class="op">}</span></a>
<a class="sourceLine" id="cb25-12" title="12">    <span class="cf">return</span> <span class="kw">false</span>;</a>
<a class="sourceLine" id="cb25-13" title="13">  <span class="op">}</span></a>
<a class="sourceLine" id="cb25-14" title="14">  <span class="co">// support for other error types..</span></a>
<a class="sourceLine" id="cb25-15" title="15"><span class="op">}</span>;</a></code></pre></div>
<p>With <code>done()</code> the error filtering concern can be extracted from <code>when_any()</code> and the rest of the algorithms that cancel. A <code>filter_error()</code> algorithm would take the predicate and forward the <code>error()</code> if the predicate returned true.</p>
<table>
<caption>using <code>when_any</code> to compose async (<code>get_data</code>)</caption>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong><code>done()</code></strong>
</div></th>
<th><div style="text-align:center">
<strong>inspect <code>error()</code></strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb26-1" title="1"><span class="kw">auto</span> foo<span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb26-2" title="2">  <span class="cf">return</span> get_data<span class="op">(</span>server0<span class="op">)</span> <span class="op">|</span> </a>
<a class="sourceLine" id="cb26-3" title="3">    filter_error<span class="op">(</span>should_fail<span class="op">{})</span> <span class="op">|</span> </a>
<a class="sourceLine" id="cb26-4" title="4">    when_any<span class="op">(</span>get_data<span class="op">(</span>server1<span class="op">)</span> <span class="op">|</span></a>
<a class="sourceLine" id="cb26-5" title="5">      filter_error<span class="op">(</span>should_fail<span class="op">{}))</span>;</a>
<a class="sourceLine" id="cb26-6" title="6"><span class="op">}</span></a></code></pre></div></td>
<td><div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb27-1" title="1"><span class="kw">auto</span> foo<span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb27-2" title="2">  <span class="cf">return</span> get_data<span class="op">(</span>server0<span class="op">)</span> <span class="op">|</span></a>
<a class="sourceLine" id="cb27-3" title="3"></a>
<a class="sourceLine" id="cb27-4" title="4">    when_any<span class="op">(</span>should_fail<span class="op">{}</span>, </a>
<a class="sourceLine" id="cb27-5" title="5">      get_data<span class="op">(</span>server1<span class="op">))</span>;</a>
<a class="sourceLine" id="cb27-6" title="6"><span class="op">}</span></a></code></pre></div></td>
</tr>
</tbody>
</table>
<p>Observe that the <code>should_fail</code> predicate is unable to distinguish which source it is filtering when it is mixed into <code>when_any</code>. Separating the filter concern into <code>filter_error()</code> provides each source with a different filter.</p>
<p>Notice also, that introducing the <code>when_any_stopped</code> error type indicates that other algorithms will need to include that type in their predicates when they wish to filter it out.</p>
<p>When cancellation is not an error, algorithms that cancel are not concerned with errors and can pass through the value and error calls unchanged. The separation of concerns provided by the <code>when_any()</code> and <code>filter_error()</code> algorithms depend on cancellation not being an error.</p>
<h2 id="algorithms-that-respond-to-errors"><span class="header-section-number">4.3</span> Algorithms that respond to errors<a href="#algorithms-that-respond-to-errors" class="self-link"></a></h2>
<p>One way to explore cancellation as separate from error is to show how treating cancellation as an error affects algorithms that respond to errors.</p>
<h3 id="a-generic-retry-algorithm"><span class="header-section-number">4.3.1</span> a generic <code>retry()</code> algorithm<a href="#a-generic-retry-algorithm" class="self-link"></a></h3>
<p><code>retry()</code> responds to errors by submitting the work again and again until it completes with success or is cancelled.</p>
<blockquote>
<p>NOTE: For the purpose of comparison this paper will use the Callback naming specified in <span class="citation" data-cites="P1660R0">[<a href="#ref-P1660R0" role="doc-biblioref">P1660R0</a>]</span> as an example of <a href="#multiple-function-style">multiple function style</a>. The names chosen for a particular expression of the <a href="#multiple-function-style">multiple function style</a> do not affect this proposal.</p>
</blockquote>
<p>When <code>done()</code> and <code>error()</code> are separate, the code for <code>retry()</code> does not need to inspect errors.</p>
<table>
<caption>generic <code>retry()</code> algorithm example (simplified for clarity)</caption>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>function</strong>
</div></th>
<th><div style="text-align:center">
<strong>pipe operator</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb28-1" title="1"><span class="kw">namespace</span> retry_alg <span class="op">{</span></a>
<a class="sourceLine" id="cb28-2" title="2"></a>
<a class="sourceLine" id="cb28-3" title="3"><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> S, <span class="kw">class</span> C<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb28-4" title="4"><span class="kw">struct</span> retry_callback <span class="op">{</span></a>
<a class="sourceLine" id="cb28-5" title="5">  S s_;</a>
<a class="sourceLine" id="cb28-6" title="6">  C c_;</a>
<a class="sourceLine" id="cb28-7" title="7">  <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span><span class="kw">auto</span><span class="op">...</span> vn<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb28-8" title="8">    c_<span class="op">(</span>vn<span class="op">...)</span>;</a>
<a class="sourceLine" id="cb28-9" title="9">  <span class="op">}</span></a>
<a class="sourceLine" id="cb28-10" title="10">  <span class="dt">void</span> error<span class="op">(</span><span class="kw">auto</span><span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb28-11" title="11">    s_<span class="op">.</span>submit<span class="op">(*</span><span class="kw">this</span><span class="op">)</span>;</a>
<a class="sourceLine" id="cb28-12" title="12">  <span class="op">}</span></a>
<a class="sourceLine" id="cb28-13" title="13">  <span class="dt">void</span> done<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb28-14" title="14">    c_<span class="op">.</span>done<span class="op">()</span>;</a>
<a class="sourceLine" id="cb28-15" title="15">  <span class="op">}</span></a>
<a class="sourceLine" id="cb28-16" title="16"><span class="op">}</span>;</a>
<a class="sourceLine" id="cb28-17" title="17"></a>
<a class="sourceLine" id="cb28-18" title="18"><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> S<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb28-19" title="19"><span class="kw">struct</span> retry_sender <span class="op">{</span></a>
<a class="sourceLine" id="cb28-20" title="20">  S s_;</a>
<a class="sourceLine" id="cb28-21" title="21">  <span class="dt">void</span> submit<span class="op">(</span>Callback <span class="kw">auto</span> c<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb28-22" title="22">    s_<span class="op">.</span>submit<span class="op">(</span></a>
<a class="sourceLine" id="cb28-23" title="23">      retry_callback<span class="op">&lt;</span>S, <span class="kw">decltype</span><span class="op">(</span>c<span class="op">)&gt;{</span>s_, c<span class="op">})</span>;</a>
<a class="sourceLine" id="cb28-24" title="24">  <span class="op">}</span></a>
<a class="sourceLine" id="cb28-25" title="25"><span class="op">}</span>;</a>
<a class="sourceLine" id="cb28-26" title="26"></a>
<a class="sourceLine" id="cb28-27" title="27"><span class="kw">struct</span> fn <span class="op">{</span></a>
<a class="sourceLine" id="cb28-28" title="28">  <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()(</span>Sender <span class="kw">auto</span> s<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb28-29" title="29">    <span class="cf">return</span> retry_sender<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>s<span class="op">)&gt;{</span>s<span class="op">}</span>;</a>
<a class="sourceLine" id="cb28-30" title="30">  <span class="op">}</span></a>
<a class="sourceLine" id="cb28-31" title="31"><span class="op">}</span>;</a>
<a class="sourceLine" id="cb28-32" title="32"></a>
<a class="sourceLine" id="cb28-33" title="33"><span class="op">}</span></a>
<a class="sourceLine" id="cb28-34" title="34"><span class="kw">constexpr</span> <span class="kw">inline</span> retry_alg<span class="op">::</span>fn retry<span class="op">{}</span>;</a></code></pre></div></td>
<td><div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb29-1" title="1"><span class="kw">namespace</span> retry_alg <span class="op">{</span></a>
<a class="sourceLine" id="cb29-2" title="2"></a>
<a class="sourceLine" id="cb29-3" title="3"><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> S, <span class="kw">class</span> C<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb29-4" title="4"><span class="kw">struct</span> retry_callback <span class="op">{</span></a>
<a class="sourceLine" id="cb29-5" title="5">  S s_;</a>
<a class="sourceLine" id="cb29-6" title="6">  C c_;</a>
<a class="sourceLine" id="cb29-7" title="7">  <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span><span class="kw">auto</span><span class="op">...</span> vn<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb29-8" title="8">    c_<span class="op">(</span>vn<span class="op">...)</span>;</a>
<a class="sourceLine" id="cb29-9" title="9">  <span class="op">}</span></a>
<a class="sourceLine" id="cb29-10" title="10">  <span class="dt">void</span> error<span class="op">(</span><span class="kw">auto</span><span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb29-11" title="11">    s_<span class="op">.</span>submit<span class="op">(*</span><span class="kw">this</span><span class="op">)</span>;</a>
<a class="sourceLine" id="cb29-12" title="12">  <span class="op">}</span></a>
<a class="sourceLine" id="cb29-13" title="13">  <span class="dt">void</span> done<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb29-14" title="14">    c_<span class="op">.</span>done<span class="op">()</span>;</a>
<a class="sourceLine" id="cb29-15" title="15">  <span class="op">}</span></a>
<a class="sourceLine" id="cb29-16" title="16"><span class="op">}</span>;</a>
<a class="sourceLine" id="cb29-17" title="17"></a>
<a class="sourceLine" id="cb29-18" title="18"><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> S<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb29-19" title="19"><span class="kw">struct</span> retry_sender <span class="op">{</span></a>
<a class="sourceLine" id="cb29-20" title="20">  S s_;</a>
<a class="sourceLine" id="cb29-21" title="21">  <span class="dt">void</span> submit<span class="op">(</span>Callback <span class="kw">auto</span> c<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb29-22" title="22">    s_<span class="op">.</span>submit<span class="op">(</span></a>
<a class="sourceLine" id="cb29-23" title="23">      retry_callback<span class="op">&lt;</span>S, <span class="kw">decltype</span><span class="op">(</span>c<span class="op">)&gt;{</span>s_, c<span class="op">})</span>;</a>
<a class="sourceLine" id="cb29-24" title="24">  <span class="op">}</span></a>
<a class="sourceLine" id="cb29-25" title="25"><span class="op">}</span>;</a>
<a class="sourceLine" id="cb29-26" title="26"></a>
<a class="sourceLine" id="cb29-27" title="27"><span class="kw">struct</span> pipe_fn <span class="op">{</span></a>
<a class="sourceLine" id="cb29-28" title="28">  <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()(</span>Sender <span class="kw">auto</span> s<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb29-29" title="29">    <span class="cf">return</span> retry_sender<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>s<span class="op">)&gt;{</span>s<span class="op">}</span>;</a>
<a class="sourceLine" id="cb29-30" title="30">  <span class="op">}</span></a>
<a class="sourceLine" id="cb29-31" title="31"><span class="op">}</span>;</a>
<a class="sourceLine" id="cb29-32" title="32"></a>
<a class="sourceLine" id="cb29-33" title="33"><span class="kw">struct</span> fn <span class="op">{</span></a>
<a class="sourceLine" id="cb29-34" title="34">  <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb29-35" title="35">    <span class="cf">return</span> pipe_fn<span class="op">{}</span>;</a>
<a class="sourceLine" id="cb29-36" title="36">  <span class="op">}</span></a>
<a class="sourceLine" id="cb29-37" title="37"><span class="op">}</span>;</a>
<a class="sourceLine" id="cb29-38" title="38"></a>
<a class="sourceLine" id="cb29-39" title="39"><span class="op">}</span></a>
<a class="sourceLine" id="cb29-40" title="40"><span class="kw">constexpr</span> <span class="kw">inline</span> retry_alg<span class="op">::</span>fn retry<span class="op">{}</span>;</a></code></pre></div></td>
</tr>
</tbody>
</table>
<p>When some errors are supposed to retry and others are not supposed to retry then an additional predicate is needed to select when to retry.</p>
<table>
<caption>generic <code>retry()</code> algorithm example with <code>done()</code> vs. inspecting <code>error()</code></caption>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong><code>done()</code></strong>
</div></th>
<th><div style="text-align:center">
<strong>inspect <code>error()</code></strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb30-1" title="1"><span class="kw">namespace</span> retry_alg <span class="op">{</span></a>
<a class="sourceLine" id="cb30-2" title="2"></a>
<a class="sourceLine" id="cb30-3" title="3"><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> S, <span class="kw">class</span> C<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb30-4" title="4"><span class="kw">struct</span> retry_callback <span class="op">{</span></a>
<a class="sourceLine" id="cb30-5" title="5">  S s_;</a>
<a class="sourceLine" id="cb30-6" title="6">  C c_;</a>
<a class="sourceLine" id="cb30-7" title="7">  <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span><span class="kw">auto</span><span class="op">...</span> vn<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb30-8" title="8">    c_<span class="op">(</span>vn<span class="op">...)</span>;</a>
<a class="sourceLine" id="cb30-9" title="9">  <span class="op">}</span></a>
<a class="sourceLine" id="cb30-10" title="10">  <span class="dt">void</span> error<span class="op">(</span><span class="kw">auto</span><span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb30-11" title="11">    s_<span class="op">.</span>submit<span class="op">(*</span><span class="kw">this</span><span class="op">)</span>;</a>
<a class="sourceLine" id="cb30-12" title="12">  <span class="op">}</span></a>
<a class="sourceLine" id="cb30-13" title="13">  <span class="dt">void</span> done<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb30-14" title="14">    c_<span class="op">.</span>done<span class="op">()</span>;</a>
<a class="sourceLine" id="cb30-15" title="15">  <span class="op">}</span></a>
<a class="sourceLine" id="cb30-16" title="16"><span class="op">}</span>;</a>
<a class="sourceLine" id="cb30-17" title="17"></a>
<a class="sourceLine" id="cb30-18" title="18"><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> S<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb30-19" title="19"><span class="kw">struct</span> retry_sender <span class="op">{</span></a>
<a class="sourceLine" id="cb30-20" title="20">  S s_;</a>
<a class="sourceLine" id="cb30-21" title="21">  <span class="dt">void</span> submit<span class="op">(</span>Callback <span class="kw">auto</span> c<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb30-22" title="22">    s_<span class="op">.</span>submit<span class="op">(</span></a>
<a class="sourceLine" id="cb30-23" title="23">      retry_callback<span class="op">&lt;</span>S, <span class="kw">decltype</span><span class="op">(</span>c<span class="op">)&gt;{</span>s_, c<span class="op">})</span>;</a>
<a class="sourceLine" id="cb30-24" title="24">  <span class="op">}</span></a>
<a class="sourceLine" id="cb30-25" title="25"><span class="op">}</span>;</a>
<a class="sourceLine" id="cb30-26" title="26"></a>
<a class="sourceLine" id="cb30-27" title="27"><span class="kw">struct</span> pipe_fn <span class="op">{</span></a>
<a class="sourceLine" id="cb30-28" title="28">  <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()(</span>Sender <span class="kw">auto</span> s<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb30-29" title="29">    <span class="cf">return</span> retry_sender<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>s<span class="op">)&gt;{</span>s<span class="op">}</span>;</a>
<a class="sourceLine" id="cb30-30" title="30">  <span class="op">}</span></a>
<a class="sourceLine" id="cb30-31" title="31"><span class="op">}</span>;</a>
<a class="sourceLine" id="cb30-32" title="32"></a>
<a class="sourceLine" id="cb30-33" title="33"><span class="kw">struct</span> fn <span class="op">{</span></a>
<a class="sourceLine" id="cb30-34" title="34">  <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb30-35" title="35">    <span class="cf">return</span> pipe_fn<span class="op">{}</span>;</a>
<a class="sourceLine" id="cb30-36" title="36">  <span class="op">}</span></a>
<a class="sourceLine" id="cb30-37" title="37"><span class="op">}</span>;</a>
<a class="sourceLine" id="cb30-38" title="38"></a>
<a class="sourceLine" id="cb30-39" title="39"><span class="op">}</span></a>
<a class="sourceLine" id="cb30-40" title="40"><span class="kw">constexpr</span> <span class="kw">inline</span> retry_alg<span class="op">::</span>fn retry<span class="op">{}</span>;</a></code></pre></div></td>
<td><div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb31-1" title="1"><span class="kw">namespace</span> retry_alg <span class="op">{</span></a>
<a class="sourceLine" id="cb31-2" title="2"></a>
<a class="sourceLine" id="cb31-3" title="3"><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> P, <span class="kw">class</span> S, <span class="kw">class</span> C<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb31-4" title="4"><span class="kw">struct</span> retry_callback <span class="op">{</span></a>
<a class="sourceLine" id="cb31-5" title="5">  P p_;</a>
<a class="sourceLine" id="cb31-6" title="6">  S s_;</a>
<a class="sourceLine" id="cb31-7" title="7">  C c_;</a>
<a class="sourceLine" id="cb31-8" title="8">  <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span><span class="kw">auto</span><span class="op">...</span> vn<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb31-9" title="9">    c_<span class="op">(</span>vn<span class="op">...)</span>;</a>
<a class="sourceLine" id="cb31-10" title="10">  <span class="op">}</span></a>
<a class="sourceLine" id="cb31-11" title="11">  <span class="dt">void</span> error<span class="op">(</span><span class="kw">auto</span> e<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb31-12" title="12">    <span class="cf">if</span> <span class="op">(</span>p_<span class="op">(</span>e<span class="op">))</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb31-13" title="13">      s_<span class="op">.</span>submit<span class="op">(*</span><span class="kw">this</span><span class="op">)</span>;</a>
<a class="sourceLine" id="cb31-14" title="14">    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb31-15" title="15">      c_<span class="op">.</span>error<span class="op">(</span>e<span class="op">)</span>;</a>
<a class="sourceLine" id="cb31-16" title="16">    <span class="op">}</span></a>
<a class="sourceLine" id="cb31-17" title="17">  <span class="op">}</span></a>
<a class="sourceLine" id="cb31-18" title="18"><span class="op">}</span>;</a>
<a class="sourceLine" id="cb31-19" title="19"></a>
<a class="sourceLine" id="cb31-20" title="20"><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> P, <span class="kw">class</span> S<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb31-21" title="21"><span class="kw">struct</span> retry_sender <span class="op">{</span></a>
<a class="sourceLine" id="cb31-22" title="22">  P p_;</a>
<a class="sourceLine" id="cb31-23" title="23">  S s_;</a>
<a class="sourceLine" id="cb31-24" title="24">  <span class="dt">void</span> submit<span class="op">(</span>Callback <span class="kw">auto</span> c<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb31-25" title="25">    s_<span class="op">.</span>submit<span class="op">(</span></a>
<a class="sourceLine" id="cb31-26" title="26">      retry_callback<span class="op">&lt;</span>P, S, <span class="kw">decltype</span><span class="op">(</span>c<span class="op">)&gt;{</span></a>
<a class="sourceLine" id="cb31-27" title="27">        p_, s_, c<span class="op">})</span>;</a>
<a class="sourceLine" id="cb31-28" title="28">  <span class="op">}</span></a>
<a class="sourceLine" id="cb31-29" title="29"><span class="op">}</span>;</a>
<a class="sourceLine" id="cb31-30" title="30"></a>
<a class="sourceLine" id="cb31-31" title="31"><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> P<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb31-32" title="32"><span class="kw">struct</span> pipe_fn <span class="op">{</span></a>
<a class="sourceLine" id="cb31-33" title="33">  P p_;</a>
<a class="sourceLine" id="cb31-34" title="34">  <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()(</span>Sender <span class="kw">auto</span> s<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb31-35" title="35">    <span class="cf">return</span> retry_sender<span class="op">&lt;</span>P, <span class="kw">decltype</span><span class="op">(</span>s<span class="op">)&gt;{</span></a>
<a class="sourceLine" id="cb31-36" title="36">      p_, s<span class="op">}</span>;</a>
<a class="sourceLine" id="cb31-37" title="37">  <span class="op">}</span></a>
<a class="sourceLine" id="cb31-38" title="38"><span class="op">}</span>;</a>
<a class="sourceLine" id="cb31-39" title="39"></a>
<a class="sourceLine" id="cb31-40" title="40"><span class="kw">struct</span> fn <span class="op">{</span></a>
<a class="sourceLine" id="cb31-41" title="41">  <span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> P<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb31-42" title="42">  <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()(</span>P p<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb31-43" title="43">    <span class="cf">return</span> pipe_fn<span class="op">&lt;</span>P<span class="op">&gt;{</span>p<span class="op">}</span>;</a>
<a class="sourceLine" id="cb31-44" title="44">  <span class="op">}</span></a>
<a class="sourceLine" id="cb31-45" title="45"><span class="op">}</span>;</a>
<a class="sourceLine" id="cb31-46" title="46"></a>
<a class="sourceLine" id="cb31-47" title="47"><span class="op">}</span></a>
<a class="sourceLine" id="cb31-48" title="48"><span class="kw">constexpr</span> <span class="kw">inline</span> retry_alg<span class="op">::</span>fn retry<span class="op">{}</span>;</a></code></pre></div></td>
</tr>
</tbody>
</table>
<p>The additional complexity of the predicate impacts each algorithm that responds to errors. The complexity also impacts each use of algorithms that respond to errors.</p>
<p>A predicate that filters the errors would have some essential complexity and overhead.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb32-1" title="1"><span class="kw">struct</span> should_retry <span class="op">{</span></a>
<a class="sourceLine" id="cb32-2" title="2">  <span class="dt">bool</span> <span class="kw">operator</span><span class="op">()(</span>std<span class="op">::</span>error_code e<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb32-3" title="3">   <span class="co">//..</span></a>
<a class="sourceLine" id="cb32-4" title="4">  <span class="op">}</span></a>
<a class="sourceLine" id="cb32-5" title="5">  <span class="dt">bool</span> <span class="kw">operator</span><span class="op">()(</span>std<span class="op">::</span>exception_ptr e<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb32-6" title="6">    <span class="cf">try</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb32-7" title="7">      std<span class="op">::</span>rethrow_exception<span class="op">(</span>e<span class="op">)</span>;</a>
<a class="sourceLine" id="cb32-8" title="8">    <span class="op">}</span> <span class="co">// support for specific exceptions..</span></a>
<a class="sourceLine" id="cb32-9" title="9">    <span class="cf">catch</span><span class="op">(...)</span> <span class="op">{</span> <span class="co">// default to retry</span></a>
<a class="sourceLine" id="cb32-10" title="10">      <span class="cf">return</span> <span class="kw">true</span>;</a>
<a class="sourceLine" id="cb32-11" title="11">    <span class="op">}</span></a>
<a class="sourceLine" id="cb32-12" title="12">    <span class="cf">return</span> <span class="kw">false</span>;</a>
<a class="sourceLine" id="cb32-13" title="13">  <span class="op">}</span></a>
<a class="sourceLine" id="cb32-14" title="14">  <span class="co">// support for other error types..</span></a>
<a class="sourceLine" id="cb32-15" title="15"><span class="op">}</span>;</a></code></pre></div>
<p>With <code>done()</code> the error filtering concern can be extracted from <code>retry()</code> and the rest of the algorithms that respond to errors. A <code>filter_error()</code> algorithm would take the predicate and forward the <code>error()</code> if the predicate returned true and emit <code>done()</code> when the predicate returned false.</p>
<table>
<caption>using <code>retry</code> to compose async (<code>get_data</code>)</caption>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong><code>done()</code></strong>
</div></th>
<th><div style="text-align:center">
<strong>inspect <code>error()</code></strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><div class="sourceCode" id="cb33"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb33-1" title="1"><span class="kw">auto</span> foo<span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb33-2" title="2">  <span class="cf">return</span> get_data<span class="op">()</span> <span class="op">|</span> </a>
<a class="sourceLine" id="cb33-3" title="3">    filter_error<span class="op">(</span>should_retry<span class="op">{})</span> <span class="op">|</span> </a>
<a class="sourceLine" id="cb33-4" title="4">    retry<span class="op">()</span>;</a>
<a class="sourceLine" id="cb33-5" title="5"><span class="op">}</span></a></code></pre></div></td>
<td><div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb34-1" title="1"><span class="kw">auto</span> foo<span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb34-2" title="2">  <span class="cf">return</span> get_data<span class="op">()</span> <span class="op">|</span> </a>
<a class="sourceLine" id="cb34-3" title="3"></a>
<a class="sourceLine" id="cb34-4" title="4">    retry<span class="op">(</span>should_retry<span class="op">{})</span>;</a>
<a class="sourceLine" id="cb34-5" title="5"><span class="op">}</span></a></code></pre></div></td>
</tr>
</tbody>
</table>
<p>When cancellation is not an error, algorithms that respond to errors are only concerned with errors and can pass through the value and done calls unchanged. The separation of concerns provided by the <code>retry()</code> and <code>filter_error()</code> algorithms depend on cancellation not being an error.</p>
<h2 id="callbacks"><span class="header-section-number">4.4</span> Callbacks<a href="#callbacks" class="self-link"></a></h2>
<p>As the most common pattern for expressing async, callbacks also need to be called with serendipitous-success. There is a lot to be said about callbacks and (<span class="citation" data-cites="P1678R0">[<a href="#ref-P1678R0" role="doc-biblioref">P1678R0</a>]</span>, <a href="https://wg21.link/p1678">latest</a>) is focused on callbacks. The following will cover only some of that larger topic.</p>
<p>Examples of callbacks can be found in the networking TS <span class="citation" data-cites="N4771">[<a href="#ref-N4771" role="doc-biblioref">N4771</a>]</span>. The completion signature for <code>async_accept()</code> is <code>void(error_code ec, socket_type s)</code>. This signature clearly displays that the first argument is used for the error channel and that the second argument is used for the value channel. Perhaps, if the completion is an object, the destructor of that object might be a signal that there was a serendipitous-success.</p>
<h3 id="destructor-style"><span class="header-section-number">4.4.1</span> destructor style<a href="#destructor-style" class="self-link"></a></h3>
<p>There are reasons not to use the destructor to signal that there was serendipitous-success.</p>
<p>The primary reason is that the compiler calls the destructor for end-of-lifetime which includes exception unwind and success unwind and unwind of a moved-from object. If the destructor is considered a signal to the Callback, then the meaning for exception unwind is <em>ignore</em> and success unwind is serendipitous-success and moved-from object unwind is <em>ignore</em>. This would force Callback destructors to handle the two cases explicitly by maintaining state; “was error() called?”, “was value() called?”, “is the object moved-from?”. Also, using the destructor to signal serendipitous-success leaves blocking as the only option for holding the lifetime of the current object for the end of some other nested or dependent async function. The state and blocking implications are both great reasons to avoid using the destructor for the serendipitous-success signal. But there is another, async vs object lifetime.</p>
<h3 id="value-and-error-arguments-style"><span class="header-section-number">4.4.2</span> value and error arguments style<a href="#value-and-error-arguments-style" class="self-link"></a></h3>
<p>Using separate arguments to a callback to represent error and value channels involves some unfortunate tradeoffs. The completion signature <code>void(error_code ec, socket_type s)</code> for <code>async_accept()</code> in <span class="citation" data-cites="N4771">[<a href="#ref-N4771" role="doc-biblioref">N4771</a>]</span> implies that the <code>socket_type</code> must support an invalid or empty state when ec contains an error. This style requires that all the parameters used in a completion signature support invalid or empty states, because the same function will be called for error and success. This requires all implementations of callbacks to check the arguments for validity before using the arguments. These checks introduce branches, which can be particularly expensive instructions.</p>
<p>Another way to represent this is to use <code>std::optional</code> explicitly on all the args so that the value types used as callback arguments are not required to support an invalid or empty state.</p>
<blockquote>
<p>NOTE: The error_code supports an empty state. The empty state for an error_code is the success code.</p>
</blockquote>
<h3 id="stdexpected-style"><span class="header-section-number">4.4.3</span> <code>std::expected</code> style<a href="#stdexpected-style" class="self-link"></a></h3>
<p>Another callback pattern is to combine the value and error into one argument. The completion signature for the <code>async_accept()</code> example might change to look something like <code>void(expected&lt;error_code, socket_type&gt; e)</code>.</p>
<p>This style does not require <code>socket_type</code> to support an invalid or empty state because it does not need to be constructed when there is an error. The branches required by the <a href="#value-and-error-arguments-style">value and error arguments style</a> are still required in this style, because the same function will be called for error and success.</p>
<p>There is also an additional cost in the codegen for packing and unpacking <code>std::expected</code>. The cost for <code>std::expected</code> is not as bad as when the value is a <code>std::tuple</code> or a <code>std::variant</code> of <code>std::tuple</code>s, but still worse than when it is an plain argument to the function. For instance, something that transforms the value from one type to another has to check the error, unpack the value or error and repack the transformed value or original error into the outgoing expected type.</p>
<h3 id="multiple-function-style"><span class="header-section-number">4.4.4</span> multiple function style<a href="#multiple-function-style" class="self-link"></a></h3>
<p>Some of the tradeoffs encountered when mixing errors and values into the same ‘channel’ (where function arguments and function return values are both channels for communication with a function), motivated the creation of the C++ exception channel. C++ exceptions do not require the implementation of a function to check for the validity of function return values before using them and do not require that function return values support invalid or empty states (basically re-implementing <code>std::optional</code> in each type) nor require the use of types that combine error/value alternatives like <code>std::expected</code>.</p>
<p>Using multiple functions for error and value is equivalent to the separation of <code>return value</code> and <code>throw</code>/<code>catch</code> in the language. Using multiple functions for error and value produces very different tradeoffs than when mixing error and value together in one function. The [<code>std::promise</code> type:] is an example of using multiple functions for error and value that already exists.</p>
<p>A challenge with the [<code>std::promise</code> type:] is that it is a type with only one implementation, whereas callbacks are intended to be a concept or signature with many implementations. There are several examples of concepts that use multiple functions for error and value. These concepts primarily differ only in the names of the concepts and the names of the functions.</p>
<ul>
<li>Reactive Extensions defines the Observer concept which has been implemented in many different languages including C++. The <a href="https://github.com/ReactiveX/RxCpp">rxcpp</a> implementation uses the names <code>Observer::on_next(T)</code>, <code>Observer::on_error(std::exception_ptr)</code> and <code>Observer::on_completed()</code></li>
<li><span class="citation" data-cites="P1055R0">[<a href="#ref-P1055R0" role="doc-biblioref">P1055R0</a>]</span> defines the Single concept using the names <code>Single::value(T)</code>, <code>Single::error(E)</code> and <code>Single::done()</code></li>
<li><span class="citation" data-cites="P1341R0">[<a href="#ref-P1341R0" role="doc-biblioref">P1341R0</a>]</span> defines the Receiver concept using the names <code>Receiver::value(Tn...)</code>, <code>Receiver::error(E)</code> and <code>Receiver::done()</code>. The <a href="https://github.com/facebookresearch/pushmi">pushmi</a> library has an implementation of the Receiver concept.</li>
<li><span class="citation" data-cites="P1660R0">[<a href="#ref-P1660R0" role="doc-biblioref">P1660R0</a>]</span> defines the Callback concept that subsumes the Invocable and Fallback concepts resulting in the names <code>Invocable::operator()(Tn...)</code>, <code>Fallback::error(E)</code> and <code>Fallback::done()</code>. <span class="citation" data-cites="P1660R0">[<a href="#ref-P1660R0" role="doc-biblioref">P1660R0</a>]</span> includes an example implementation.</li>
</ul>
<p>The Callback concept defined in <span class="citation" data-cites="P1660R0">[<a href="#ref-P1660R0" role="doc-biblioref">P1660R0</a>]</span> has been gaining support in SG1 recently. A completion object for the <code>async_accept()</code> example might change to look something like:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb35-1" title="1"><span class="kw">struct</span> async_accept_completion <span class="op">{</span></a>
<a class="sourceLine" id="cb35-2" title="2">  <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span>socket_type s<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="kw">noexcept</span>;</a>
<a class="sourceLine" id="cb35-3" title="3">  <span class="dt">void</span> error<span class="op">(</span>error_code<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="kw">noexcept</span>;</a>
<a class="sourceLine" id="cb35-4" title="4">  <span class="dt">void</span> error<span class="op">(</span>exception_ptr<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="kw">noexcept</span>;</a>
<a class="sourceLine" id="cb35-5" title="5">  <span class="dt">void</span> done<span class="op">()</span> <span class="op">&amp;&amp;</span> <span class="kw">noexcept</span>;</a>
<a class="sourceLine" id="cb35-6" title="6"><span class="op">}</span>;</a></code></pre></div>
<p>Where:</p>
<ul>
<li><code>operator()</code> is only called for success</li>
<li><code>error()</code> is only called for failure</li>
<li><code>done()</code> is only called for serendipitous-success</li>
</ul>
<p>Provides:</p>
<ul>
<li>each function can be specified to be called on a different execution agent</li>
<li>value types do not need to represent invalid or empty states</li>
<li>none of the functions are required to add branches and checks for errors or validity</li>
<li>all types are passed as function arguments with no required packing/unpacking</li>
<li>overloads of each method allow different types to be supported without use of <code>std::variant</code></li>
<li>overloads of each method allow different numbers of arguments to be supported without use of <code>std::optional</code> or <code>std::variant&lt;std::tuple&lt;&gt;...&gt;</code></li>
</ul>
<h3 id="gratuitous"><span class="header-section-number">4.4.5</span> gratuitous<a href="#gratuitous" class="self-link"></a></h3>
<blockquote>
<p>Note: This is for those that object to named methods on an Invocable object.</p>
</blockquote>
<p>In an imaginary world these could be renamed as operators in the language. Say that:</p>
<ul>
<li><code>void error(E)</code> became <code>void operator catch(E)</code></li>
<li><code>void done()</code> became <code>void operator break return()</code></li>
<li>where <code>catch(callback, std::current_exception());</code> called <code>callback.operator catch(std::current_exception());</code></li>
<li>where <code>break return (callback);</code> called <code>callback.operator break return();</code></li>
</ul>
<p>Staying with the <code>async_accept</code> example <code>async_accept_completion</code> might look like this:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb36-1" title="1"><span class="kw">struct</span> async_accept_completion <span class="op">{</span></a>
<a class="sourceLine" id="cb36-2" title="2">  <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span>socket_type s<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="kw">noexcept</span>;</a>
<a class="sourceLine" id="cb36-3" title="3">  <span class="dt">void</span> <span class="kw">operator</span> <span class="cf">catch</span><span class="op">(</span>error_code<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="kw">noexcept</span>;</a>
<a class="sourceLine" id="cb36-4" title="4">  <span class="dt">void</span> <span class="kw">operator</span> <span class="cf">catch</span><span class="op">(</span>exception_ptr<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="kw">noexcept</span>;</a>
<a class="sourceLine" id="cb36-5" title="5">  <span class="dt">void</span> <span class="kw">operator</span> <span class="cf">break</span> <span class="cf">return</span><span class="op">()</span> <span class="op">&amp;&amp;</span> <span class="kw">noexcept</span>;</a>
<a class="sourceLine" id="cb36-6" title="6"><span class="op">}</span>;</a></code></pre></div>
<p>other capabilities of <code>break return</code> are imagined in <a href="#scope_success-scope_fail-scope_done-blocks">scope_success, scope_fail, scope_done blocks</a></p>
<h2 id="exception-noise"><span class="header-section-number">4.5</span> Exception noise<a href="#exception-noise" class="self-link"></a></h2>
<p>Cancellation is very common when using async functions. Reporting cancellations as exceptions creates a lot of noise because cancellation is expected to occur frequently.</p>
<p>This noise affects logging and debugging and other forms of analysis. exceptions used to report cancellation have to be filtered or categorized in many different tools and libraries to control for that noise.</p>
<h2 id="sync-functions-not-a-typo"><span class="header-section-number">4.6</span> sync functions (not a typo)<a href="#sync-functions-not-a-typo" class="self-link"></a></h2>
<p>sync functions also need to complete with serendipitous-success.</p>
<p>The clearest expression of this involves coroutines and generators. Another example is <code>std::optional</code>.</p>
<h3 id="coroutine-generator"><span class="header-section-number">4.6.1</span> coroutine generator<a href="#coroutine-generator" class="self-link"></a></h3>
<p>This example is also made clearer by avoiding Iterators.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb37-1" title="1"><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb37-2" title="2"><span class="kw">struct</span> generator <span class="op">{</span></a>
<a class="sourceLine" id="cb37-3" title="3">  T next<span class="op">()</span> <span class="op">{..}</span></a>
<a class="sourceLine" id="cb37-4" title="4"><span class="op">}</span>;</a>
<a class="sourceLine" id="cb37-5" title="5"></a>
<a class="sourceLine" id="cb37-6" title="6">generator<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> fortyTwos<span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb37-7" title="7">  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span>; i <span class="op">&lt;</span> <span class="dv">5</span>; <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb37-8" title="8">    <span class="co">// the g.next() </span></a>
<a class="sourceLine" id="cb37-9" title="9">    <span class="co">// resumes with the int 42</span></a>
<a class="sourceLine" id="cb37-10" title="10">    <span class="kw">co_yield</span> <span class="dv">42</span>;</a>
<a class="sourceLine" id="cb37-11" title="11">  <span class="op">}</span></a>
<a class="sourceLine" id="cb37-12" title="12"></a>
<a class="sourceLine" id="cb37-13" title="13">  <span class="co">// the g.next() </span></a>
<a class="sourceLine" id="cb37-14" title="14">  <span class="co">// resumes with?</span></a>
<a class="sourceLine" id="cb37-15" title="15">  <span class="kw">co_return</span>;</a>
<a class="sourceLine" id="cb37-16" title="16"><span class="op">}</span></a>
<a class="sourceLine" id="cb37-17" title="17"></a>
<a class="sourceLine" id="cb37-18" title="18"><span class="co">// assumes that g.next() </span></a>
<a class="sourceLine" id="cb37-19" title="19"><span class="co">// completes with serendipitous-success</span></a>
<a class="sourceLine" id="cb37-20" title="20"><span class="dt">void</span> foo<span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb37-21" title="21">  <span class="kw">auto</span> g <span class="op">=</span> fortyTwos<span class="op">()</span>;</a>
<a class="sourceLine" id="cb37-22" title="22">  <span class="cf">for</span><span class="op">(</span>;;<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb37-23" title="23">    <span class="kw">auto</span> fortyTwo <span class="op">=</span> g<span class="op">.</span>next<span class="op">()</span>;</a>
<a class="sourceLine" id="cb37-24" title="24">  <span class="op">}</span></a>
<a class="sourceLine" id="cb37-25" title="25"><span class="op">}</span></a></code></pre></div>
<p>Notice that <code>generator</code> is a channel that connects two loops, the producer loop and the consumer loop. Each loop may independently break to exit. When break is used in one loop, the channel must have a way to cause the other loop to break as well. This signal is not an error, <code>throw</code> is not a good way to represent <code>break</code>. The iterator concept encodes <code>break</code> into the value by allowing <code>end()</code> to represent an empty iterator.</p>
<p>Another way to say the same thing, is that types like <code>generator&lt;int&gt;</code> actually create a coroutine whose body is allowed to produce two different value types. <code>co_yield 42;</code> resolves the matching <code>g.next()</code> with an int while <code>co_return;</code> resumes the matching <code>g.next()</code> with void.</p>
<p>Obviously <code>next()</code> returning <code>int</code> and <code>void</code> does not work in C++ today, which is why <code>generator</code> must model something more complicated like a Range where <code>begin()</code> and <code>operator++()</code> both produce iterators that are either a proxy to the yielded value or compare equal to <code>end()</code> when <code>void</code> is returned.</p>
<p>While this value encoding seems natural for Range, it is not so palatable for <code>std::optional</code>.</p>
<h3 id="stdoptional"><span class="header-section-number">4.6.2</span> <code>std::optional</code><a href="#stdoptional" class="self-link"></a></h3>
<p>Range (with size 0|1), <code>std::optional</code> and even <code>std::variant&lt;std::monostate,..&gt;</code> are ways to model optional values in C++. They are themselves values that provide access to a value or nothing.</p>
<p>It might seem that if cancellation is not an error that <code>std::optional</code> would allow cancellation to be composed into the return value rather than as an exception. This path was rejected previously because of the impact that it would have on code. all return values for all functions that could be cancelled or would use functions that could be cancelled would have to return <code>std::optional</code>. All callers of functions that returned <code>std::optional</code> would have to explicitly check, extract the value or forward on the empty <code>std::optional</code>. This wrapping and unwrapping is expensive at runtime and messy in the code and very error prone (the cancellation may not propagate when it should). These are all reasons that C++ exceptions have a separate channel and thus motivate a separate channel for serendipitous-success.</p>
<h2 id="examples"><span class="header-section-number">4.7</span> Examples<a href="#examples" class="self-link"></a></h2>
<p>An imaginary world, where a sync function can complete with serendipitous-success, would have cleaner code.</p>
<table>
<caption><code>op()</code> that produces an empty value when a feature is not supported vs. imaginary <code>op()</code> that emits serendipitous-success</caption>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Real</strong>
</div></th>
<th><div style="text-align:center">
<strong>Imaginary</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb38-1" title="1">std<span class="op">::</span>optional<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> op<span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb38-2" title="2">  <span class="cf">if</span> <span class="op">(!</span>has_feature<span class="op">())</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb38-3" title="3">    <span class="cf">return</span> <span class="op">{}</span>;</a>
<a class="sourceLine" id="cb38-4" title="4">  <span class="op">}</span></a>
<a class="sourceLine" id="cb38-5" title="5">  <span class="cf">return</span> feature<span class="op">()</span>;</a>
<a class="sourceLine" id="cb38-6" title="6"><span class="op">}</span></a>
<a class="sourceLine" id="cb38-7" title="7"></a>
<a class="sourceLine" id="cb38-8" title="8"><span class="dt">void</span> foo<span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb38-9" title="9">  <span class="co">// ..</span></a>
<a class="sourceLine" id="cb38-10" title="10">  <span class="kw">auto</span> i <span class="op">=</span> op<span class="op">()</span>;</a>
<a class="sourceLine" id="cb38-11" title="11">  <span class="cf">if</span> <span class="op">(!</span>i<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb38-12" title="12">    <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb38-13" title="13">  <span class="op">}</span></a>
<a class="sourceLine" id="cb38-14" title="14">  <span class="co">// use *i..</span></a>
<a class="sourceLine" id="cb38-15" title="15"><span class="op">}</span> <span class="co">// jumps here when the feature is </span></a>
<a class="sourceLine" id="cb38-16" title="16">  <span class="co">// not supported</span></a></code></pre></div></td>
<td><div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb39-1" title="1"><span class="dt">int</span> op<span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb39-2" title="2">  <span class="cf">if</span> <span class="op">(!</span>has_feature<span class="op">())</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb39-3" title="3">    <span class="cf">break</span> <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb39-4" title="4">  <span class="op">}</span></a>
<a class="sourceLine" id="cb39-5" title="5">  <span class="cf">return</span> feature<span class="op">()</span>;</a>
<a class="sourceLine" id="cb39-6" title="6"><span class="op">}</span></a>
<a class="sourceLine" id="cb39-7" title="7"></a>
<a class="sourceLine" id="cb39-8" title="8"><span class="dt">void</span> foo<span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb39-9" title="9">  <span class="co">// ..</span></a>
<a class="sourceLine" id="cb39-10" title="10">  <span class="kw">auto</span> i <span class="op">=</span> op<span class="op">()</span>;</a>
<a class="sourceLine" id="cb39-11" title="11">  <span class="co">// use i..</span></a>
<a class="sourceLine" id="cb39-12" title="12"><span class="op">}</span> <span class="co">// jumps here when the feature is </span></a>
<a class="sourceLine" id="cb39-13" title="13">  <span class="co">// not supported</span></a></code></pre></div></td>
</tr>
</tbody>
</table>
<table>
<caption><code>op()</code> that produces an error when a feature is not supported vs. imaginary <code>op()</code> that emits serendipitous-success</caption>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Real</strong>
</div></th>
<th><div style="text-align:center">
<strong>Imaginary</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb40-1" title="1"><span class="dt">int</span> op<span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb40-2" title="2">  <span class="cf">if</span> <span class="op">(!</span>has_feature<span class="op">())</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb40-3" title="3">    <span class="cf">throw</span> unsupported_error<span class="op">()</span>;</a>
<a class="sourceLine" id="cb40-4" title="4">  <span class="op">}</span></a>
<a class="sourceLine" id="cb40-5" title="5">  <span class="cf">return</span> feature<span class="op">()</span>;</a>
<a class="sourceLine" id="cb40-6" title="6"><span class="op">}</span></a>
<a class="sourceLine" id="cb40-7" title="7"></a>
<a class="sourceLine" id="cb40-8" title="8"><span class="dt">void</span> foo<span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb40-9" title="9">  <span class="co">// ..</span></a>
<a class="sourceLine" id="cb40-10" title="10">  <span class="cf">try</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb40-11" title="11">    <span class="kw">auto</span> i <span class="op">=</span> op<span class="op">()</span>;</a>
<a class="sourceLine" id="cb40-12" title="12">    <span class="co">// use *i..</span></a>
<a class="sourceLine" id="cb40-13" title="13">  <span class="op">}</span> <span class="cf">catch</span><span class="op">(</span><span class="kw">const</span> unsupported_error<span class="op">&amp;)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb40-14" title="14">    <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb40-15" title="15">  <span class="op">}</span></a>
<a class="sourceLine" id="cb40-16" title="16"><span class="op">}</span> <span class="co">// jumps here when the feature is </span></a>
<a class="sourceLine" id="cb40-17" title="17">  <span class="co">// not supported</span></a></code></pre></div></td>
<td><div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb41-1" title="1"><span class="dt">int</span> op<span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb41-2" title="2">  <span class="cf">if</span> <span class="op">(!</span>has_feature<span class="op">())</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb41-3" title="3">    <span class="cf">break</span> <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb41-4" title="4">  <span class="op">}</span></a>
<a class="sourceLine" id="cb41-5" title="5">  <span class="cf">return</span> feature<span class="op">()</span>;</a>
<a class="sourceLine" id="cb41-6" title="6"><span class="op">}</span></a>
<a class="sourceLine" id="cb41-7" title="7"></a>
<a class="sourceLine" id="cb41-8" title="8"><span class="dt">void</span> foo<span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb41-9" title="9">  <span class="co">// ..</span></a>
<a class="sourceLine" id="cb41-10" title="10">  <span class="kw">auto</span> i <span class="op">=</span> op<span class="op">()</span>;</a>
<a class="sourceLine" id="cb41-11" title="11">  <span class="co">// use i..</span></a>
<a class="sourceLine" id="cb41-12" title="12"><span class="op">}</span> <span class="co">// jumps here when the feature is </span></a>
<a class="sourceLine" id="cb41-13" title="13">  <span class="co">// not supported</span></a></code></pre></div></td>
</tr>
</tbody>
</table>
<h3 id="fgh"><span class="header-section-number">4.7.1</span> <code>f(g(h()))</code><a href="#fgh" class="self-link"></a></h3>
<p>Given a simple composition of the functions <code>f()</code>, <code>g()</code>, <code>h()</code>, demonstrate various forms of cancellation within their implementations.</p>
<ul>
<li><code>h()</code> will return a task that produces a void result each time it is invoked (unless it has been cancelled)</li>
<li><code>g()</code> will return a task that that calls the task argument 9 times then cancels</li>
<li><code>f()</code> will wait for the task argument to complete and print the results</li>
</ul>
<p>These first implementations are sync functions that use <code>optional&lt;&gt;</code> to compose <code>f()</code>, <code>g()</code>, and <code>h()</code>.</p>
<table>
<caption>composition - explicit vs. lazy</caption>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Explicit</strong>
</div></th>
<th><div style="text-align:center">
<strong>Lazy</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb42-1" title="1"><span class="co">// usage</span></a>
<a class="sourceLine" id="cb42-2" title="2"><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb42-3" title="3">  f<span class="op">()</span>;</a>
<a class="sourceLine" id="cb42-4" title="4"><span class="op">}</span></a></code></pre></div></td>
<td><div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb43-1" title="1"><span class="co">// usage</span></a>
<a class="sourceLine" id="cb43-2" title="2"><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb43-3" title="3">  f<span class="op">(</span>g<span class="op">(</span>h<span class="op">()))</span>;</a>
<a class="sourceLine" id="cb43-4" title="4"><span class="op">}</span></a></code></pre></div></td>
</tr>
<tr class="even">
<td><div class="sourceCode" id="cb44"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb44-1" title="1"><span class="kw">using</span> void_value <span class="op">=</span> tuple<span class="op">&lt;&gt;</span>;</a>
<a class="sourceLine" id="cb44-2" title="2"><span class="kw">auto</span> h<span class="op">(</span>stop_token stop<span class="op">)</span> </a>
<a class="sourceLine" id="cb44-3" title="3">  <span class="op">-&gt;</span> optional<span class="op">&lt;</span>void_value<span class="op">&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb44-4" title="4">  <span class="cf">if</span><span class="op">(</span>stop<span class="op">.</span>stop_requested<span class="op">())</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb44-5" title="5">    <span class="cf">return</span> nullopt;</a>
<a class="sourceLine" id="cb44-6" title="6">  <span class="op">}</span></a>
<a class="sourceLine" id="cb44-7" title="7">  <span class="cf">return</span> void_value<span class="op">{}</span>;</a>
<a class="sourceLine" id="cb44-8" title="8"><span class="op">}</span></a></code></pre></div></td>
<td><div class="sourceCode" id="cb45"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb45-1" title="1"><span class="kw">using</span> void_value <span class="op">=</span> tuple<span class="op">&lt;&gt;</span>;</a>
<a class="sourceLine" id="cb45-2" title="2"><span class="kw">auto</span> h<span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb45-3" title="3">  <span class="cf">return</span> <span class="op">[](</span>stop_token stop<span class="op">)</span> </a>
<a class="sourceLine" id="cb45-4" title="4">    <span class="op">-&gt;</span> optional<span class="op">&lt;</span>void_value<span class="op">&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb45-5" title="5">    <span class="cf">if</span><span class="op">(</span>stop<span class="op">.</span>stop_requested<span class="op">())</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb45-6" title="6">      <span class="cf">return</span> nullopt;</a>
<a class="sourceLine" id="cb45-7" title="7">    <span class="op">}</span></a>
<a class="sourceLine" id="cb45-8" title="8">    <span class="cf">return</span> void_value<span class="op">{}</span>;</a>
<a class="sourceLine" id="cb45-9" title="9">  <span class="op">}</span>;</a>
<a class="sourceLine" id="cb45-10" title="10"><span class="op">}</span></a></code></pre></div></td>
</tr>
<tr class="odd">
<td><div class="sourceCode" id="cb46"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb46-1" title="1"><span class="kw">auto</span> g<span class="op">(</span>stop_token stop<span class="op">)</span> </a>
<a class="sourceLine" id="cb46-2" title="2">  <span class="op">-&gt;</span> optional<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb46-3" title="3">  <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb46-4" title="4">  stop_source stopInner;</a>
<a class="sourceLine" id="cb46-5" title="5">  <span class="cf">for</span> <span class="op">(</span>;;<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb46-6" title="6">    <span class="cf">if</span> <span class="op">(</span>stop<span class="op">.</span>stop_requested<span class="op">())</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb46-7" title="7">      stopInner<span class="op">.</span>request_stop<span class="op">()</span>;</a>
<a class="sourceLine" id="cb46-8" title="8">    <span class="op">}</span></a>
<a class="sourceLine" id="cb46-9" title="9">    <span class="cf">if</span> <span class="op">(!</span>h<span class="op">(</span>stopInner<span class="op">.</span>get_token<span class="op">()))</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb46-10" title="10">      <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb46-11" title="11">    <span class="op">}</span></a>
<a class="sourceLine" id="cb46-12" title="12">    <span class="cf">if</span> <span class="op">(++</span>count <span class="op">&gt;=</span> <span class="dv">9</span><span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb46-13" title="13">      stopInner<span class="op">.</span>request_stop<span class="op">()</span>;</a>
<a class="sourceLine" id="cb46-14" title="14">    <span class="op">}</span></a>
<a class="sourceLine" id="cb46-15" title="15">  <span class="op">}</span></a>
<a class="sourceLine" id="cb46-16" title="16">  <span class="cf">return</span> count;</a>
<a class="sourceLine" id="cb46-17" title="17"><span class="op">}</span></a></code></pre></div></td>
<td><div class="sourceCode" id="cb47"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb47-1" title="1"><span class="kw">auto</span> g<span class="op">(</span><span class="kw">auto</span> h<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb47-2" title="2">  <span class="cf">return</span> <span class="op">[</span>h<span class="op">](</span>stop_token stop<span class="op">)</span> </a>
<a class="sourceLine" id="cb47-3" title="3">    <span class="op">-&gt;</span> optional<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb47-4" title="4">    <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb47-5" title="5">    stop_source stopInner;</a>
<a class="sourceLine" id="cb47-6" title="6">    <span class="cf">for</span> <span class="op">(</span>;;<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb47-7" title="7">      <span class="cf">if</span> <span class="op">(</span>stop<span class="op">.</span>stop_requested<span class="op">())</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb47-8" title="8">        stopInner<span class="op">.</span>request_stop<span class="op">()</span>;</a>
<a class="sourceLine" id="cb47-9" title="9">      <span class="op">}</span></a>
<a class="sourceLine" id="cb47-10" title="10">      <span class="cf">if</span> <span class="op">(!</span>h<span class="op">(</span>stopInner<span class="op">.</span>get_token<span class="op">()))</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb47-11" title="11">        <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb47-12" title="12">      <span class="op">}</span></a>
<a class="sourceLine" id="cb47-13" title="13">      <span class="cf">if</span> <span class="op">(++</span>count <span class="op">&gt;=</span> <span class="dv">9</span><span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb47-14" title="14">        stopInner<span class="op">.</span>request_stop<span class="op">()</span>;</a>
<a class="sourceLine" id="cb47-15" title="15">      <span class="op">}</span></a>
<a class="sourceLine" id="cb47-16" title="16">    <span class="op">}</span></a>
<a class="sourceLine" id="cb47-17" title="17">    <span class="cf">return</span> count;</a>
<a class="sourceLine" id="cb47-18" title="18">  <span class="op">}</span>;</a>
<a class="sourceLine" id="cb47-19" title="19"><span class="op">}</span></a></code></pre></div></td>
</tr>
<tr class="even">
<td><div class="sourceCode" id="cb48"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb48-1" title="1"><span class="dt">void</span> f<span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb48-2" title="2">  exception_ptr ex;</a>
<a class="sourceLine" id="cb48-3" title="3">  stop_source stop;</a>
<a class="sourceLine" id="cb48-4" title="4">  optional<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> count;</a>
<a class="sourceLine" id="cb48-5" title="5">  thread t<span class="op">{[&amp;](){</span></a>
<a class="sourceLine" id="cb48-6" title="6">    this_thread<span class="op">::</span>sleep_for<span class="op">(</span><span class="dv">100</span><span class="bu">ms</span><span class="op">)</span>;</a>
<a class="sourceLine" id="cb48-7" title="7">    stop<span class="op">.</span>request_stop<span class="op">()</span>;</a>
<a class="sourceLine" id="cb48-8" title="8">  <span class="op">}}</span>;</a>
<a class="sourceLine" id="cb48-9" title="9">  <span class="cf">try</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb48-10" title="10">    count <span class="op">=</span> g<span class="op">(</span>stop<span class="op">.</span>get_token<span class="op">())</span>;</a>
<a class="sourceLine" id="cb48-11" title="11">  <span class="op">}</span> <span class="cf">catch</span><span class="op">(...)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb48-12" title="12">    ex <span class="op">=</span> current_exception<span class="op">()</span>;</a>
<a class="sourceLine" id="cb48-13" title="13">  <span class="op">}</span></a>
<a class="sourceLine" id="cb48-14" title="14">  <span class="kw">auto</span> w <span class="op">=</span> <span class="op">(</span></a>
<a class="sourceLine" id="cb48-15" title="15">    <span class="op">!!</span>count <span class="op">?</span> <span class="st">&quot;completed&quot;</span> <span class="op">:</span></a>
<a class="sourceLine" id="cb48-16" title="16">    <span class="op">!!</span>ex <span class="op">?</span> <span class="st">&quot;failed&quot;</span> <span class="op">:</span></a>
<a class="sourceLine" id="cb48-17" title="17">    <span class="op">!</span>count <span class="op">?</span> <span class="st">&quot;stopped&quot;</span> <span class="op">:</span> <span class="st">&quot;invalid&quot;</span><span class="op">)</span>;</a>
<a class="sourceLine" id="cb48-18" title="18">  printf<span class="op">(</span><span class="st">&quot;which </span><span class="sc">%s</span><span class="st">, count </span><span class="sc">%d</span><span class="st">&quot;</span>, w, <span class="op">*</span>count<span class="op">)</span>;</a>
<a class="sourceLine" id="cb48-19" title="19">  t<span class="op">.</span>join<span class="op">()</span>;</a>
<a class="sourceLine" id="cb48-20" title="20"><span class="op">}</span></a></code></pre></div></td>
<td><div class="sourceCode" id="cb49"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb49-1" title="1"><span class="dt">void</span> f<span class="op">(</span><span class="kw">auto</span> g<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb49-2" title="2">  exception_ptr ex;</a>
<a class="sourceLine" id="cb49-3" title="3">  stop_source stop;</a>
<a class="sourceLine" id="cb49-4" title="4">  optional<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> count;</a>
<a class="sourceLine" id="cb49-5" title="5">  thread t<span class="op">{[&amp;](){</span></a>
<a class="sourceLine" id="cb49-6" title="6">    this_thread<span class="op">::</span>sleep_for<span class="op">(</span><span class="dv">100</span><span class="bu">ms</span><span class="op">)</span>;</a>
<a class="sourceLine" id="cb49-7" title="7">    stop<span class="op">.</span>request_stop<span class="op">()</span>;</a>
<a class="sourceLine" id="cb49-8" title="8">  <span class="op">}}</span>;</a>
<a class="sourceLine" id="cb49-9" title="9">  <span class="cf">try</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb49-10" title="10">    count <span class="op">=</span> g<span class="op">(</span>stop<span class="op">.</span>get_token<span class="op">())</span>;</a>
<a class="sourceLine" id="cb49-11" title="11">  <span class="op">}</span> <span class="cf">catch</span><span class="op">(...)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb49-12" title="12">    ex <span class="op">=</span> current_exception<span class="op">()</span>;</a>
<a class="sourceLine" id="cb49-13" title="13">  <span class="op">}</span></a>
<a class="sourceLine" id="cb49-14" title="14">  <span class="kw">auto</span> w <span class="op">=</span> <span class="op">(</span></a>
<a class="sourceLine" id="cb49-15" title="15">    <span class="op">!!</span>count <span class="op">?</span> <span class="st">&quot;completed&quot;</span> <span class="op">:</span></a>
<a class="sourceLine" id="cb49-16" title="16">    <span class="op">!!</span>ex <span class="op">?</span> <span class="st">&quot;failed&quot;</span> <span class="op">:</span></a>
<a class="sourceLine" id="cb49-17" title="17">    <span class="op">!</span>count <span class="op">?</span> <span class="st">&quot;stopped&quot;</span> <span class="op">:</span> <span class="st">&quot;invalid&quot;</span><span class="op">)</span>;</a>
<a class="sourceLine" id="cb49-18" title="18">  printf<span class="op">(</span><span class="st">&quot;which </span><span class="sc">%s</span><span class="st">, count </span><span class="sc">%d</span><span class="st">&quot;</span>, w, <span class="op">*</span>count<span class="op">)</span>;</a>
<a class="sourceLine" id="cb49-19" title="19">  t<span class="op">.</span>join<span class="op">()</span>;</a>
<a class="sourceLine" id="cb49-20" title="20"><span class="op">}</span></a></code></pre></div></td>
</tr>
</tbody>
</table>
<p>The Explicit composition demonstrates one level of composition, Lazy demonstrates another level of composition that is needed to allow functions to be chained in an expression. This is similar to the difference between <code>std::transform</code> and <code>std::views::transform</code>.</p>
<p>The rest of these implementations have been structured to support the Lazy form of composition.</p>
<hr />
<p>This demonstrates an async implementation with a Library composition model that has cancellation support.</p>
<blockquote>
<p>NOTE: For the purpose of comparison this paper will use the Callback naming specified in <span class="citation" data-cites="P1660R0">[<a href="#ref-P1660R0" role="doc-biblioref">P1660R0</a>]</span> as an example of <a href="#multiple-function-style">multiple function style</a>. The names chosen for a particular expression of the <a href="#multiple-function-style">multiple function style</a> do not affect this proposal.</p>
</blockquote>
<div class="sourceCode" id="cb50"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb50-1" title="1"><span class="kw">struct</span> h_task <span class="op">{</span></a>
<a class="sourceLine" id="cb50-2" title="2">  <span class="dt">void</span> submit<span class="op">(</span>Callback <span class="kw">auto</span> c<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb50-3" title="3">    <span class="cf">try</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb50-4" title="4">      thread t<span class="op">([</span>c<span class="op">]()</span> <span class="kw">mutable</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb50-5" title="5">        <span class="cf">if</span><span class="op">(</span>c<span class="op">.</span>get_stop_token<span class="op">().</span>stop_requested<span class="op">())</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb50-6" title="6">          c<span class="op">.</span>done<span class="op">()</span>;</a>
<a class="sourceLine" id="cb50-7" title="7">        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb50-8" title="8">          c<span class="op">()</span>;</a>
<a class="sourceLine" id="cb50-9" title="9">        <span class="op">}</span></a>
<a class="sourceLine" id="cb50-10" title="10">      <span class="op">})</span>;</a>
<a class="sourceLine" id="cb50-11" title="11">      t<span class="op">.</span>detach<span class="op">()</span>;</a>
<a class="sourceLine" id="cb50-12" title="12">    <span class="op">}</span> <span class="cf">catch</span><span class="op">(...)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb50-13" title="13">      c<span class="op">.</span>error<span class="op">(</span>std<span class="op">::</span>current_exception<span class="op">())</span>;</a>
<a class="sourceLine" id="cb50-14" title="14">    <span class="op">}</span></a>
<a class="sourceLine" id="cb50-15" title="15">  <span class="op">}</span></a>
<a class="sourceLine" id="cb50-16" title="16"><span class="op">}</span>;</a>
<a class="sourceLine" id="cb50-17" title="17">h_task h<span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb50-18" title="18">  <span class="cf">return</span> <span class="op">{}</span>;</a>
<a class="sourceLine" id="cb50-19" title="19"><span class="op">}</span></a></code></pre></div>
<div class="sourceCode" id="cb51"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb51-1" title="1"><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> H, <span class="kw">class</span> C<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb51-2" title="2"><span class="kw">struct</span> g_callback <span class="op">{</span></a>
<a class="sourceLine" id="cb51-3" title="3">  H h_;</a>
<a class="sourceLine" id="cb51-4" title="4">  C c_;</a>
<a class="sourceLine" id="cb51-5" title="5">  <span class="dt">int</span> count_ <span class="op">=</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb51-6" title="6">  stop_source stop_;</a>
<a class="sourceLine" id="cb51-7" title="7">  stop_token get_stop_token<span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb51-8" title="8">    <span class="cf">return</span> stop_<span class="op">.</span>get_token<span class="op">()</span>;</a>
<a class="sourceLine" id="cb51-9" title="9">  <span class="op">}</span></a>
<a class="sourceLine" id="cb51-10" title="10">  <span class="dt">void</span> <span class="kw">operator</span><span class="op">()()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb51-11" title="11">    <span class="cf">if</span> <span class="op">(</span>c_<span class="op">.</span>get_stop_token<span class="op">().</span>stop_requested<span class="op">())</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb51-12" title="12">      stop_<span class="op">.</span>request_stop<span class="op">()</span>;</a>
<a class="sourceLine" id="cb51-13" title="13">    <span class="op">}</span></a>
<a class="sourceLine" id="cb51-14" title="14">    <span class="op">++</span>count_;</a>
<a class="sourceLine" id="cb51-15" title="15">    <span class="cf">try</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb51-16" title="16">      <span class="cf">if</span> <span class="op">(</span>count_ <span class="op">&lt;</span> <span class="dv">9</span><span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb51-17" title="17">        h_<span class="op">.</span>submit<span class="op">(*</span><span class="kw">this</span><span class="op">)</span>;</a>
<a class="sourceLine" id="cb51-18" title="18">      <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb51-19" title="19">        stop_<span class="op">.</span>request_stop<span class="op">()</span>;</a>
<a class="sourceLine" id="cb51-20" title="20">        h_<span class="op">.</span>submit<span class="op">(*</span><span class="kw">this</span><span class="op">)</span>;</a>
<a class="sourceLine" id="cb51-21" title="21">      <span class="op">}</span></a>
<a class="sourceLine" id="cb51-22" title="22">    <span class="op">}</span> <span class="cf">catch</span><span class="op">(...)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb51-23" title="23">      c_<span class="op">.</span>error<span class="op">(</span>std<span class="op">::</span>current_exception<span class="op">())</span>;</a>
<a class="sourceLine" id="cb51-24" title="24">    <span class="op">}</span></a>
<a class="sourceLine" id="cb51-25" title="25">  <span class="op">}</span></a>
<a class="sourceLine" id="cb51-26" title="26">  <span class="dt">void</span> error<span class="op">(</span><span class="kw">auto</span> e<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb51-27" title="27">    <span class="cf">if</span> <span class="op">(</span>c_<span class="op">.</span>get_stop_token<span class="op">().</span>stop_requested<span class="op">())</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb51-28" title="28">      stop_<span class="op">.</span>request_stop<span class="op">()</span>;</a>
<a class="sourceLine" id="cb51-29" title="29">    <span class="op">}</span></a>
<a class="sourceLine" id="cb51-30" title="30">    c_<span class="op">.</span>error<span class="op">(</span>e<span class="op">)</span>;</a>
<a class="sourceLine" id="cb51-31" title="31">  <span class="op">}</span></a>
<a class="sourceLine" id="cb51-32" title="32">  <span class="dt">void</span> done<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb51-33" title="33">    <span class="cf">if</span> <span class="op">(</span>c_<span class="op">.</span>get_stop_token<span class="op">().</span>stop_requested<span class="op">())</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb51-34" title="34">      c_<span class="op">.</span>done<span class="op">()</span>;</a>
<a class="sourceLine" id="cb51-35" title="35">      <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb51-36" title="36">    <span class="op">}</span></a>
<a class="sourceLine" id="cb51-37" title="37">    <span class="cf">try</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb51-38" title="38">      c_<span class="op">(</span>count_<span class="op">)</span>;</a>
<a class="sourceLine" id="cb51-39" title="39">    <span class="op">}</span> <span class="cf">catch</span><span class="op">(...)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb51-40" title="40">      c_<span class="op">.</span>error<span class="op">(</span>std<span class="op">::</span>current_exception<span class="op">())</span>;</a>
<a class="sourceLine" id="cb51-41" title="41">    <span class="op">}</span></a>
<a class="sourceLine" id="cb51-42" title="42">  <span class="op">}</span></a>
<a class="sourceLine" id="cb51-43" title="43"><span class="op">}</span>;</a>
<a class="sourceLine" id="cb51-44" title="44"><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> H<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb51-45" title="45"><span class="kw">struct</span> g_task <span class="op">{</span></a>
<a class="sourceLine" id="cb51-46" title="46">  H h_;</a>
<a class="sourceLine" id="cb51-47" title="47">  <span class="dt">void</span> submit<span class="op">(</span>Callback <span class="kw">auto</span> c<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb51-48" title="48">    <span class="cf">try</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb51-49" title="49">      h_<span class="op">.</span>submit<span class="op">(</span>g_callback<span class="op">&lt;</span>H, <span class="kw">decltype</span><span class="op">(</span>c<span class="op">)&gt;{</span></a>
<a class="sourceLine" id="cb51-50" title="50">        h_, c<span class="op">})</span>;</a>
<a class="sourceLine" id="cb51-51" title="51">    <span class="op">}</span> <span class="cf">catch</span><span class="op">(...)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb51-52" title="52">      c<span class="op">.</span>error<span class="op">(</span>std<span class="op">::</span>current_exception<span class="op">())</span>;</a>
<a class="sourceLine" id="cb51-53" title="53">    <span class="op">}</span></a>
<a class="sourceLine" id="cb51-54" title="54">  <span class="op">}</span></a>
<a class="sourceLine" id="cb51-55" title="55"><span class="op">}</span>;</a>
<a class="sourceLine" id="cb51-56" title="56"><span class="kw">auto</span> g<span class="op">(</span>Sender <span class="kw">auto</span> h<span class="op">)</span> </a>
<a class="sourceLine" id="cb51-57" title="57">  <span class="op">-&gt;</span> g_task<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>h<span class="op">)&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb51-58" title="58">  <span class="cf">return</span> <span class="op">{</span>h<span class="op">}</span>;</a>
<a class="sourceLine" id="cb51-59" title="59"><span class="op">}</span></a></code></pre></div>
<div class="sourceCode" id="cb52"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb52-1" title="1"><span class="kw">struct</span> f_callback <span class="op">{</span></a>
<a class="sourceLine" id="cb52-2" title="2">  stop_token stop_;</a>
<a class="sourceLine" id="cb52-3" title="3">  atomic<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> which_;</a>
<a class="sourceLine" id="cb52-4" title="4">  atomic<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> count_;</a>
<a class="sourceLine" id="cb52-5" title="5">  stop_token get_stop_token<span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb52-6" title="6">    <span class="cf">return</span> stop_;</a>
<a class="sourceLine" id="cb52-7" title="7">  <span class="op">}</span></a>
<a class="sourceLine" id="cb52-8" title="8">  <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span><span class="dt">int</span> count<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb52-9" title="9">    count_<span class="op">.</span>exchange<span class="op">(</span>count<span class="op">)</span>;</a>
<a class="sourceLine" id="cb52-10" title="10">    which_<span class="op">.</span>exchange<span class="op">(</span><span class="dv">1</span><span class="op">)</span>;</a>
<a class="sourceLine" id="cb52-11" title="11">  <span class="op">}</span></a>
<a class="sourceLine" id="cb52-12" title="12">  <span class="dt">void</span> error<span class="op">(</span><span class="kw">auto</span> e<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb52-13" title="13">    which_<span class="op">.</span>exchange<span class="op">(</span><span class="dv">2</span><span class="op">)</span>;</a>
<a class="sourceLine" id="cb52-14" title="14">  <span class="op">}</span></a>
<a class="sourceLine" id="cb52-15" title="15">  <span class="dt">void</span> done<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb52-16" title="16">    which_<span class="op">.</span>exchange<span class="op">(</span><span class="dv">3</span><span class="op">)</span>;</a>
<a class="sourceLine" id="cb52-17" title="17">  <span class="op">}</span></a>
<a class="sourceLine" id="cb52-18" title="18"><span class="op">}</span>;</a>
<a class="sourceLine" id="cb52-19" title="19"><span class="dt">void</span> f<span class="op">(</span><span class="kw">auto</span> g<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb52-20" title="20">  stop_source stop;</a>
<a class="sourceLine" id="cb52-21" title="21">  atomic<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> which<span class="op">{</span><span class="dv">0</span><span class="op">}</span>;</a>
<a class="sourceLine" id="cb52-22" title="22">  atomic<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> count<span class="op">{</span><span class="dv">0</span><span class="op">}</span>;</a>
<a class="sourceLine" id="cb52-23" title="23">  thread t<span class="op">{[&amp;](){</span></a>
<a class="sourceLine" id="cb52-24" title="24">    this_thread<span class="op">::</span>sleep_for<span class="op">(</span><span class="dv">100</span><span class="bu">ms</span><span class="op">)</span>;</a>
<a class="sourceLine" id="cb52-25" title="25">    stop<span class="op">.</span>request_stop<span class="op">()</span>;</a>
<a class="sourceLine" id="cb52-26" title="26">  <span class="op">}}</span>;</a>
<a class="sourceLine" id="cb52-27" title="27">  f_callback r<span class="op">{</span>stop<span class="op">.</span>get_token<span class="op">()</span>, which, count<span class="op">}</span>;</a>
<a class="sourceLine" id="cb52-28" title="28">  g<span class="op">.</span>submit<span class="op">(</span>r<span class="op">)</span>;</a>
<a class="sourceLine" id="cb52-29" title="29">  stop<span class="op">.</span>request_stop<span class="op">()</span>;</a>
<a class="sourceLine" id="cb52-30" title="30">  <span class="cf">while</span><span class="op">(</span>which<span class="op">.</span>load<span class="op">()</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span>;</a>
<a class="sourceLine" id="cb52-31" title="31">  <span class="kw">auto</span> w <span class="op">=</span> <span class="op">(</span></a>
<a class="sourceLine" id="cb52-32" title="32">    which<span class="op">.</span>load<span class="op">()</span> <span class="op">==</span> <span class="dv">1</span> <span class="op">?</span> <span class="st">&quot;completed&quot;</span> <span class="op">:</span></a>
<a class="sourceLine" id="cb52-33" title="33">    which<span class="op">.</span>load<span class="op">()</span> <span class="op">==</span> <span class="dv">2</span> <span class="op">?</span> <span class="st">&quot;failed&quot;</span> <span class="op">:</span></a>
<a class="sourceLine" id="cb52-34" title="34">    which<span class="op">.</span>load<span class="op">()</span> <span class="op">==</span> <span class="dv">3</span> <span class="op">?</span> <span class="st">&quot;stopped&quot;</span> <span class="op">:</span> <span class="st">&quot;invalid&quot;</span><span class="op">)</span>;</a>
<a class="sourceLine" id="cb52-35" title="35">  printf<span class="op">(</span><span class="st">&quot;which </span><span class="sc">%s</span><span class="st">, count </span><span class="sc">%d</span><span class="st">&quot;</span>, w, count<span class="op">.</span>load<span class="op">())</span>;</a>
<a class="sourceLine" id="cb52-36" title="36">  t<span class="op">.</span>join<span class="op">()</span>;</a>
<a class="sourceLine" id="cb52-37" title="37"><span class="op">}</span></a></code></pre></div>
<hr />
<p>This implementation demonstrates a sync implementation with a Library composition model that uses the return value to support cancellation.</p>
<table>
<caption>serendipitous-success - return value vs. imaginary language feature</caption>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Real</strong>
</div></th>
<th><div style="text-align:center">
<strong>Imaginary</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><div class="sourceCode" id="cb53"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb53-1" title="1"><span class="kw">using</span> void_value <span class="op">=</span> tuple<span class="op">&lt;&gt;</span>;</a>
<a class="sourceLine" id="cb53-2" title="2"><span class="kw">auto</span> h<span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb53-3" title="3">  <span class="cf">return</span> <span class="op">[](</span>stop_token stop<span class="op">)</span> </a>
<a class="sourceLine" id="cb53-4" title="4">    <span class="op">-&gt;</span> optional<span class="op">&lt;</span>void_value<span class="op">&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb53-5" title="5">    <span class="cf">if</span><span class="op">(</span>stop<span class="op">.</span>stop_requested<span class="op">())</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb53-6" title="6">      <span class="cf">return</span> nullopt;</a>
<a class="sourceLine" id="cb53-7" title="7">    <span class="op">}</span></a>
<a class="sourceLine" id="cb53-8" title="8">    <span class="cf">return</span> void_value<span class="op">{}</span>;</a>
<a class="sourceLine" id="cb53-9" title="9">  <span class="op">}</span>;</a>
<a class="sourceLine" id="cb53-10" title="10"><span class="op">}</span></a></code></pre></div></td>
<td><div class="sourceCode" id="cb54"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb54-1" title="1"><span class="kw">auto</span> h<span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb54-2" title="2">  <span class="cf">return</span> <span class="op">[](</span>stop_token stop<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb54-3" title="3">    <span class="cf">if</span><span class="op">(</span>stop<span class="op">.</span>stop_requested<span class="op">())</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb54-4" title="4">      <span class="cf">break</span> <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb54-5" title="5">    <span class="op">}</span></a>
<a class="sourceLine" id="cb54-6" title="6">    <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb54-7" title="7">  <span class="op">}</span>;</a>
<a class="sourceLine" id="cb54-8" title="8"><span class="op">}</span></a></code></pre></div></td>
</tr>
<tr class="even">
<td><div class="sourceCode" id="cb55"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb55-1" title="1"><span class="kw">auto</span> g<span class="op">(</span><span class="kw">auto</span> h<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb55-2" title="2">  <span class="cf">return</span> <span class="op">[</span>h<span class="op">](</span>stop_token stop<span class="op">)</span> </a>
<a class="sourceLine" id="cb55-3" title="3">    <span class="op">-&gt;</span> optional<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb55-4" title="4">    <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb55-5" title="5">    stop_source stopInner;</a>
<a class="sourceLine" id="cb55-6" title="6">    <span class="cf">for</span> <span class="op">(</span>;;<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb55-7" title="7">      <span class="cf">if</span> <span class="op">(</span>stop<span class="op">.</span>stop_requested<span class="op">())</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb55-8" title="8">        stopInner<span class="op">.</span>request_stop<span class="op">()</span>;</a>
<a class="sourceLine" id="cb55-9" title="9">      <span class="op">}</span></a>
<a class="sourceLine" id="cb55-10" title="10">      <span class="cf">if</span> <span class="op">(!</span>h<span class="op">(</span>stopInner<span class="op">.</span>get_token<span class="op">()))</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb55-11" title="11">        <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb55-12" title="12">      <span class="op">}</span></a>
<a class="sourceLine" id="cb55-13" title="13">      <span class="cf">if</span> <span class="op">(++</span>count <span class="op">&gt;=</span> <span class="dv">9</span><span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb55-14" title="14">        stopInner<span class="op">.</span>request_stop<span class="op">()</span>;</a>
<a class="sourceLine" id="cb55-15" title="15">      <span class="op">}</span></a>
<a class="sourceLine" id="cb55-16" title="16">    <span class="op">}</span></a>
<a class="sourceLine" id="cb55-17" title="17">    <span class="cf">return</span> count;</a>
<a class="sourceLine" id="cb55-18" title="18">  <span class="op">}</span>;</a>
<a class="sourceLine" id="cb55-19" title="19"><span class="op">}</span></a></code></pre></div></td>
<td><div class="sourceCode" id="cb56"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb56-1" title="1"><span class="kw">auto</span> g<span class="op">(</span><span class="kw">auto</span> h<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb56-2" title="2">  <span class="cf">return</span> <span class="op">[</span>h<span class="op">](</span>stop_token stop<span class="op">)</span> </a>
<a class="sourceLine" id="cb56-3" title="3">    <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb56-4" title="4">    <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb56-5" title="5">    stop_source stopInner;</a>
<a class="sourceLine" id="cb56-6" title="6">    <span class="cf">for</span> <span class="op">(</span>;;<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb56-7" title="7">      <span class="cf">if</span> <span class="op">(</span>stop<span class="op">.</span>stop_requested<span class="op">())</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb56-8" title="8">        stopInner<span class="op">.</span>request_stop<span class="op">()</span>;</a>
<a class="sourceLine" id="cb56-9" title="9">      <span class="op">}</span></a>
<a class="sourceLine" id="cb56-10" title="10">      <span class="op">{</span></a>
<a class="sourceLine" id="cb56-11" title="11">        scope_done <span class="op">{</span><span class="cf">break</span>;<span class="op">}</span></a>
<a class="sourceLine" id="cb56-12" title="12">        h<span class="op">(</span>stopInner<span class="op">.</span>get_token<span class="op">())</span>;</a>
<a class="sourceLine" id="cb56-13" title="13">      <span class="op">}</span></a>
<a class="sourceLine" id="cb56-14" title="14">      <span class="cf">if</span> <span class="op">(++</span>count <span class="op">&gt;=</span> <span class="dv">9</span><span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb56-15" title="15">        stopInner<span class="op">.</span>request_stop<span class="op">()</span>;</a>
<a class="sourceLine" id="cb56-16" title="16">      <span class="op">}</span></a>
<a class="sourceLine" id="cb56-17" title="17">    <span class="op">}</span></a>
<a class="sourceLine" id="cb56-18" title="18">    <span class="cf">return</span> count;</a>
<a class="sourceLine" id="cb56-19" title="19">  <span class="op">}</span>;</a>
<a class="sourceLine" id="cb56-20" title="20"><span class="op">}</span></a></code></pre></div></td>
</tr>
<tr class="odd">
<td><div class="sourceCode" id="cb57"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb57-1" title="1"><span class="dt">void</span> f<span class="op">(</span><span class="kw">auto</span> g<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb57-2" title="2">  exception_ptr ex;</a>
<a class="sourceLine" id="cb57-3" title="3">  stop_source stop;</a>
<a class="sourceLine" id="cb57-4" title="4">  optional<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> count;</a>
<a class="sourceLine" id="cb57-5" title="5">  thread t<span class="op">{[&amp;](){</span></a>
<a class="sourceLine" id="cb57-6" title="6">    this_thread<span class="op">::</span>sleep_for<span class="op">(</span><span class="dv">100</span><span class="bu">ms</span><span class="op">)</span>;</a>
<a class="sourceLine" id="cb57-7" title="7">    stop<span class="op">.</span>request_stop<span class="op">()</span>;</a>
<a class="sourceLine" id="cb57-8" title="8">  <span class="op">}}</span>;</a>
<a class="sourceLine" id="cb57-9" title="9">  <span class="cf">try</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb57-10" title="10">    count <span class="op">=</span> g<span class="op">(</span>stop<span class="op">.</span>get_token<span class="op">())</span>;</a>
<a class="sourceLine" id="cb57-11" title="11">  <span class="op">}</span> <span class="cf">catch</span><span class="op">(...)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb57-12" title="12">    ex <span class="op">=</span> current_exception<span class="op">()</span>;</a>
<a class="sourceLine" id="cb57-13" title="13">  <span class="op">}</span></a>
<a class="sourceLine" id="cb57-14" title="14">  <span class="kw">auto</span> w <span class="op">=</span> <span class="op">(</span></a>
<a class="sourceLine" id="cb57-15" title="15">    <span class="op">!!</span>count <span class="op">?</span> <span class="st">&quot;completed&quot;</span> <span class="op">:</span></a>
<a class="sourceLine" id="cb57-16" title="16">    <span class="op">!!</span>ex <span class="op">?</span> <span class="st">&quot;failed&quot;</span> <span class="op">:</span></a>
<a class="sourceLine" id="cb57-17" title="17">    <span class="op">!</span>count <span class="op">?</span> <span class="st">&quot;stopped&quot;</span> <span class="op">:</span> <span class="st">&quot;invalid&quot;</span><span class="op">)</span>;</a>
<a class="sourceLine" id="cb57-18" title="18">  printf<span class="op">(</span><span class="st">&quot;which </span><span class="sc">%s</span><span class="st">, count </span><span class="sc">%d</span><span class="st">&quot;</span>, w, <span class="op">*</span>count<span class="op">)</span>;</a>
<a class="sourceLine" id="cb57-19" title="19">  t<span class="op">.</span>join<span class="op">()</span>;</a>
<a class="sourceLine" id="cb57-20" title="20"><span class="op">}</span></a></code></pre></div></td>
<td><div class="sourceCode" id="cb58"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb58-1" title="1"><span class="dt">void</span> f<span class="op">(</span><span class="kw">auto</span> g<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb58-2" title="2">  exception_ptr ex;</a>
<a class="sourceLine" id="cb58-3" title="3">  stop_source stop;</a>
<a class="sourceLine" id="cb58-4" title="4">  optional<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> count;</a>
<a class="sourceLine" id="cb58-5" title="5">  thread t<span class="op">{[&amp;](){</span></a>
<a class="sourceLine" id="cb58-6" title="6">    this_thread<span class="op">::</span>sleep_for<span class="op">(</span><span class="dv">100</span><span class="bu">ms</span><span class="op">)</span>;</a>
<a class="sourceLine" id="cb58-7" title="7">    stop<span class="op">.</span>request_stop<span class="op">()</span>;</a>
<a class="sourceLine" id="cb58-8" title="8">  <span class="op">}}</span>;</a>
<a class="sourceLine" id="cb58-9" title="9">  <span class="kw">auto</span> print <span class="op">=</span> <span class="op">[&amp;]()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb58-10" title="10">    <span class="kw">auto</span> w <span class="op">=</span> <span class="op">(</span></a>
<a class="sourceLine" id="cb58-11" title="11">      <span class="op">!!</span>count <span class="op">?</span> <span class="st">&quot;completed&quot;</span> <span class="op">:</span></a>
<a class="sourceLine" id="cb58-12" title="12">      <span class="op">!!</span>ex <span class="op">?</span> <span class="st">&quot;failed&quot;</span> <span class="op">:</span></a>
<a class="sourceLine" id="cb58-13" title="13">      <span class="op">!</span>count <span class="op">?</span> <span class="st">&quot;stopped&quot;</span> <span class="op">:</span> <span class="st">&quot;invalid&quot;</span><span class="op">)</span>;</a>
<a class="sourceLine" id="cb58-14" title="14">    printf<span class="op">(</span><span class="st">&quot;which </span><span class="sc">%s</span><span class="st">, count </span><span class="sc">%d</span><span class="st">&quot;</span>, w, <span class="op">*</span>count<span class="op">)</span>;</a>
<a class="sourceLine" id="cb58-15" title="15">  <span class="op">}</span>;</a>
<a class="sourceLine" id="cb58-16" title="16">  <span class="cf">try</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb58-17" title="17">    scope_done <span class="op">{</span>print<span class="op">()</span>;<span class="op">}</span></a>
<a class="sourceLine" id="cb58-18" title="18">    count <span class="op">=</span> g<span class="op">(</span>stop<span class="op">.</span>get_token<span class="op">())</span>;</a>
<a class="sourceLine" id="cb58-19" title="19">  <span class="op">}</span> <span class="cf">catch</span><span class="op">(...)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb58-20" title="20">    ex <span class="op">=</span> current_exception<span class="op">()</span>;</a>
<a class="sourceLine" id="cb58-21" title="21">  <span class="op">}</span></a>
<a class="sourceLine" id="cb58-22" title="22">  print<span class="op">()</span>;</a>
<a class="sourceLine" id="cb58-23" title="23">  t<span class="op">.</span>join<span class="op">()</span>;</a>
<a class="sourceLine" id="cb58-24" title="24"><span class="op">}</span></a></code></pre></div></td>
</tr>
</tbody>
</table>
<p>This implementation demonstrates a sync implementation with a Library composition model that uses <code>throw</code> to support cancellation.</p>
<table>
<caption>serendipitous-success - <code>throw</code> vs. imaginary language feature</caption>
<thead>
<tr class="header">
<th><div style="text-align:center">
<strong>Real</strong>
</div></th>
<th><div style="text-align:center">
<strong>Imaginary</strong>
</div></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><div class="sourceCode" id="cb59"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb59-1" title="1"><span class="kw">struct</span> stopped_exception <span class="op">:</span> exception <span class="op">{}</span>;</a>
<a class="sourceLine" id="cb59-2" title="2"><span class="kw">auto</span> h<span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb59-3" title="3">  <span class="cf">return</span> <span class="op">[](</span>stop_token stop<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb59-4" title="4">    <span class="cf">if</span><span class="op">(</span>stop<span class="op">.</span>stop_requested<span class="op">())</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb59-5" title="5">      <span class="cf">throw</span> stopped_exception<span class="op">{}</span>;</a>
<a class="sourceLine" id="cb59-6" title="6">    <span class="op">}</span></a>
<a class="sourceLine" id="cb59-7" title="7">    <span class="cf">return</span> ;</a>
<a class="sourceLine" id="cb59-8" title="8">  <span class="op">}</span>;</a>
<a class="sourceLine" id="cb59-9" title="9"><span class="op">}</span></a></code></pre></div></td>
<td><div class="sourceCode" id="cb60"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb60-1" title="1"><span class="kw">auto</span> h<span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb60-2" title="2">  <span class="cf">return</span> <span class="op">[](</span>stop_token stop<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb60-3" title="3">    <span class="cf">if</span><span class="op">(</span>stop<span class="op">.</span>stop_requested<span class="op">())</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb60-4" title="4">      <span class="cf">break</span> <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb60-5" title="5">    <span class="op">}</span></a>
<a class="sourceLine" id="cb60-6" title="6">    <span class="cf">return</span>;</a>
<a class="sourceLine" id="cb60-7" title="7">  <span class="op">}</span>;</a>
<a class="sourceLine" id="cb60-8" title="8"><span class="op">}</span></a></code></pre></div></td>
</tr>
<tr class="even">
<td><div class="sourceCode" id="cb61"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb61-1" title="1"><span class="kw">auto</span> g<span class="op">(</span><span class="kw">auto</span> h<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb61-2" title="2">  <span class="cf">return</span> <span class="op">[</span>h<span class="op">](</span>stop_token stop<span class="op">)</span> </a>
<a class="sourceLine" id="cb61-3" title="3">    <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb61-4" title="4">    <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb61-5" title="5">    stop_source stopInner;</a>
<a class="sourceLine" id="cb61-6" title="6">    <span class="cf">for</span> <span class="op">(</span>;;<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb61-7" title="7">      <span class="cf">if</span> <span class="op">(</span>stop<span class="op">.</span>stop_requested<span class="op">())</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb61-8" title="8">        stopInner<span class="op">.</span>request_stop<span class="op">()</span>;</a>
<a class="sourceLine" id="cb61-9" title="9">      <span class="op">}</span></a>
<a class="sourceLine" id="cb61-10" title="10">      <span class="cf">try</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb61-11" title="11">        h<span class="op">(</span>stopInner<span class="op">.</span>get_token<span class="op">())</span>;</a>
<a class="sourceLine" id="cb61-12" title="12">      <span class="op">}</span> <span class="cf">catch</span> <span class="op">(</span><span class="kw">const</span> stopped_exception<span class="op">&amp;)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb61-13" title="13">        <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb61-14" title="14">      <span class="op">}</span></a>
<a class="sourceLine" id="cb61-15" title="15">      <span class="cf">if</span> <span class="op">(++</span>count <span class="op">&gt;=</span> <span class="dv">9</span><span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb61-16" title="16">        stopInner<span class="op">.</span>request_stop<span class="op">()</span>;</a>
<a class="sourceLine" id="cb61-17" title="17">      <span class="op">}</span></a>
<a class="sourceLine" id="cb61-18" title="18">    <span class="op">}</span></a>
<a class="sourceLine" id="cb61-19" title="19">    <span class="cf">return</span> count;</a>
<a class="sourceLine" id="cb61-20" title="20">  <span class="op">}</span>;</a>
<a class="sourceLine" id="cb61-21" title="21"><span class="op">}</span></a></code></pre></div></td>
<td><div class="sourceCode" id="cb62"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb62-1" title="1"><span class="kw">auto</span> g<span class="op">(</span><span class="kw">auto</span> h<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb62-2" title="2">  <span class="cf">return</span> <span class="op">[</span>h<span class="op">](</span>stop_token stop<span class="op">)</span> </a>
<a class="sourceLine" id="cb62-3" title="3">    <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb62-4" title="4">    <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb62-5" title="5">    stop_source stopInner;</a>
<a class="sourceLine" id="cb62-6" title="6">    <span class="cf">for</span> <span class="op">(</span>;;<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb62-7" title="7">      <span class="cf">if</span> <span class="op">(</span>stop<span class="op">.</span>stop_requested<span class="op">())</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb62-8" title="8">        stopInner<span class="op">.</span>request_stop<span class="op">()</span>;</a>
<a class="sourceLine" id="cb62-9" title="9">      <span class="op">}</span></a>
<a class="sourceLine" id="cb62-10" title="10">      <span class="op">{</span></a>
<a class="sourceLine" id="cb62-11" title="11">        scope_done <span class="op">{</span><span class="cf">break</span>;<span class="op">}</span></a>
<a class="sourceLine" id="cb62-12" title="12">        h<span class="op">(</span>stopInner<span class="op">.</span>get_token<span class="op">())</span>;</a>
<a class="sourceLine" id="cb62-13" title="13">      <span class="op">}</span></a>
<a class="sourceLine" id="cb62-14" title="14">      <span class="cf">if</span> <span class="op">(++</span>count <span class="op">&gt;=</span> <span class="dv">9</span><span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb62-15" title="15">        stopInner<span class="op">.</span>request_stop<span class="op">()</span>;</a>
<a class="sourceLine" id="cb62-16" title="16">      <span class="op">}</span></a>
<a class="sourceLine" id="cb62-17" title="17">    <span class="op">}</span></a>
<a class="sourceLine" id="cb62-18" title="18">    <span class="cf">return</span> count;</a>
<a class="sourceLine" id="cb62-19" title="19">  <span class="op">}</span>;</a>
<a class="sourceLine" id="cb62-20" title="20"><span class="op">}</span></a></code></pre></div></td>
</tr>
<tr class="odd">
<td><div class="sourceCode" id="cb63"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb63-1" title="1"><span class="dt">void</span> f<span class="op">(</span><span class="kw">auto</span> g<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb63-2" title="2">  exception_ptr ex;</a>
<a class="sourceLine" id="cb63-3" title="3">  stop_source stop;</a>
<a class="sourceLine" id="cb63-4" title="4">  optional<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> count;</a>
<a class="sourceLine" id="cb63-5" title="5">  thread t<span class="op">{[&amp;](){</span></a>
<a class="sourceLine" id="cb63-6" title="6">    this_thread<span class="op">::</span>sleep_for<span class="op">(</span><span class="dv">100</span><span class="bu">ms</span><span class="op">)</span>;</a>
<a class="sourceLine" id="cb63-7" title="7">    stop<span class="op">.</span>request_stop<span class="op">()</span>;</a>
<a class="sourceLine" id="cb63-8" title="8">  <span class="op">}}</span>;</a>
<a class="sourceLine" id="cb63-9" title="9">  <span class="cf">try</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb63-10" title="10">    count <span class="op">=</span> g<span class="op">(</span>stop<span class="op">.</span>get_token<span class="op">())</span>;</a>
<a class="sourceLine" id="cb63-11" title="11">  <span class="op">}</span> <span class="cf">catch</span> <span class="op">(</span><span class="kw">const</span> stopped_exception<span class="op">&amp;)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb63-12" title="12">  <span class="op">}</span> <span class="cf">catch</span><span class="op">(...)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb63-13" title="13">    ex <span class="op">=</span> current_exception<span class="op">()</span>;</a>
<a class="sourceLine" id="cb63-14" title="14">  <span class="op">}</span></a>
<a class="sourceLine" id="cb63-15" title="15">  <span class="kw">auto</span> w <span class="op">=</span> <span class="op">(</span></a>
<a class="sourceLine" id="cb63-16" title="16">    <span class="op">!!</span>count <span class="op">?</span> <span class="st">&quot;completed&quot;</span> <span class="op">:</span></a>
<a class="sourceLine" id="cb63-17" title="17">    <span class="op">!!</span>ex <span class="op">?</span> <span class="st">&quot;failed&quot;</span> <span class="op">:</span></a>
<a class="sourceLine" id="cb63-18" title="18">    <span class="op">!</span>count <span class="op">?</span> <span class="st">&quot;stopped&quot;</span> <span class="op">:</span> <span class="st">&quot;invalid&quot;</span><span class="op">)</span>;</a>
<a class="sourceLine" id="cb63-19" title="19">  printf<span class="op">(</span><span class="st">&quot;which </span><span class="sc">%s</span><span class="st">, count </span><span class="sc">%d</span><span class="st">&quot;</span>, w, <span class="op">*</span>count<span class="op">)</span>;</a>
<a class="sourceLine" id="cb63-20" title="20">  t<span class="op">.</span>join<span class="op">()</span>;</a>
<a class="sourceLine" id="cb63-21" title="21"><span class="op">}</span></a></code></pre></div></td>
<td><div class="sourceCode" id="cb64"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb64-1" title="1"><span class="dt">void</span> f<span class="op">(</span><span class="kw">auto</span> g<span class="op">)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb64-2" title="2">  exception_ptr ex;</a>
<a class="sourceLine" id="cb64-3" title="3">  stop_source stop;</a>
<a class="sourceLine" id="cb64-4" title="4">  optional<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> count;</a>
<a class="sourceLine" id="cb64-5" title="5">  thread t<span class="op">{[&amp;](){</span></a>
<a class="sourceLine" id="cb64-6" title="6">    this_thread<span class="op">::</span>sleep_for<span class="op">(</span><span class="dv">100</span><span class="bu">ms</span><span class="op">)</span>;</a>
<a class="sourceLine" id="cb64-7" title="7">    stop<span class="op">.</span>request_stop<span class="op">()</span>;</a>
<a class="sourceLine" id="cb64-8" title="8">  <span class="op">}}</span>;</a>
<a class="sourceLine" id="cb64-9" title="9">  <span class="kw">auto</span> print <span class="op">=</span> <span class="op">[&amp;]()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb64-10" title="10">    <span class="kw">auto</span> w <span class="op">=</span> <span class="op">(</span></a>
<a class="sourceLine" id="cb64-11" title="11">      <span class="op">!!</span>count <span class="op">?</span> <span class="st">&quot;completed&quot;</span> <span class="op">:</span></a>
<a class="sourceLine" id="cb64-12" title="12">      <span class="op">!!</span>ex <span class="op">?</span> <span class="st">&quot;failed&quot;</span> <span class="op">:</span></a>
<a class="sourceLine" id="cb64-13" title="13">      <span class="op">!</span>count <span class="op">?</span> <span class="st">&quot;stopped&quot;</span> <span class="op">:</span> <span class="st">&quot;invalid&quot;</span><span class="op">)</span>;</a>
<a class="sourceLine" id="cb64-14" title="14">    printf<span class="op">(</span><span class="st">&quot;which </span><span class="sc">%s</span><span class="st">, count </span><span class="sc">%d</span><span class="st">&quot;</span>, w, <span class="op">*</span>count<span class="op">)</span>;</a>
<a class="sourceLine" id="cb64-15" title="15">  <span class="op">}</span>;</a>
<a class="sourceLine" id="cb64-16" title="16">  <span class="cf">try</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb64-17" title="17">    scope_done <span class="op">{</span>print<span class="op">()</span>;<span class="op">}</span></a>
<a class="sourceLine" id="cb64-18" title="18">    count <span class="op">=</span> g<span class="op">(</span>stop<span class="op">.</span>get_token<span class="op">())</span>;</a>
<a class="sourceLine" id="cb64-19" title="19">  <span class="op">}</span> <span class="cf">catch</span><span class="op">(...)</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb64-20" title="20">    ex <span class="op">=</span> current_exception<span class="op">()</span>;</a>
<a class="sourceLine" id="cb64-21" title="21">  <span class="op">}</span></a>
<a class="sourceLine" id="cb64-22" title="22">  print<span class="op">()</span>;</a>
<a class="sourceLine" id="cb64-23" title="23">  t<span class="op">.</span>join<span class="op">()</span>;</a>
<a class="sourceLine" id="cb64-24" title="24"><span class="op">}</span></a></code></pre></div></td>
</tr>
</tbody>
</table>
<h1 id="conclusions"><span class="header-section-number">5</span> Conclusions<a href="#conclusions" class="self-link"></a></h1>
<p>The cancellations, covered in <a href="#motivation">Motivation</a> above, are not errors and the functions that were cancelled should complete with serendipitous-success.</p>
<p>Further, cancellation is not the only case covered in <a href="#motivation">Motivation</a> above, where a function would benefit from completing with serendipitous-success.</p>
<p>Finally, serendipitous-success is a signal that does not have a good representation using the existing forms of function output.</p>
<h2 id="function-output"><span class="header-section-number">5.1</span> Function output<a href="#function-output" class="self-link"></a></h2>
<p>Here is a short description of the options currently in the language for functions to return values. These options boil down to three channels; return value, out-parameter arguments, and throwing exceptions.</p>
<h3 id="values"><span class="header-section-number">5.1.1</span> Values<a href="#values" class="self-link"></a></h3>
<p>In C, there are three ways to communicate a result:</p>
<ul>
<li>return a value</li>
<li>set value(s) into out-parameter(s)</li>
<li>call a parameter, that is a function, with arguments(s)</li>
</ul>
<h3 id="exceptions"><span class="header-section-number">5.1.2</span> Exceptions<a href="#exceptions" class="self-link"></a></h3>
<p>C++ added a third mechanism for communicating a result - throwing exceptions. Adding exception throwing as a separate communication channel allowed code to focus on the path of success and delegate the responsibility for exception handling to the caller by default. C++ made support for exceptions implicit. Functions do not have a mechanism to opt-in to exception support. Functions can opt out of emitting exceptions using <code>noexcept</code>, but the compiler still is responsible for ensuring that an attempt to throw an exception in a <code>noexcept</code> function will result in a call to <code>std::terminate</code>.</p>
<h3 id="multiplexing"><span class="header-section-number">5.1.3</span> Multiplexing<a href="#multiplexing" class="self-link"></a></h3>
<p>These mechanisms can be multiplexed and de-multiplexed, with additional overhead in code size and runtime.</p>
<p>Examples of mux for return values and out-parameters:</p>
<ul>
<li><code>optional&lt;T&gt;</code> allows return without a value.</li>
<li><code>expected&lt;E, T&gt;</code> allows an error to be returned without an exception.</li>
<li><code>expected&lt;E, optional&lt;T&gt;&gt;</code> allows an error to be returned without an exception and for nothing to be returned.</li>
<li><code>expected&lt;optional&lt;variant&lt;tuple&lt;Tn0...&gt;, tuple&lt;Tn1...&gt;, ..&gt;&gt;, E&gt;</code> allows the parameters that are supported by one of an overload set of callback functions to be returned as a value and an error to be returned without an exception and for nothing to be returned.</li>
</ul>
<p>Potential syntax to simplify the code that needs to be written to demux these values can be found in the proposal for pattern matching <span class="citation" data-cites="P1371R0">[<a href="#ref-P1371R0" role="doc-biblioref">P1371R0</a>]</span>.</p>
<blockquote>
<p>NOTE: while <code>expected</code>, <code>variant</code> and <code>tuple</code> all correspond to C++ language features (exception &amp; return value <code>expected</code>, overload set of functions <code>variant</code>, and multiple arguments to a function <code>tuple</code>), <code>optional</code> does not have a language representation. Pointer is not a language representation as<code>optional</code> is a super-set of Pointer, because <code>optional</code> stores the value when it is valid, while Pointer does not.</p>
</blockquote>
<h2 id="contrast-function-taking-a-callback-with-function"><span class="header-section-number">5.2</span> Contrast function-taking-a-callback with function<a href="#contrast-function-taking-a-callback-with-function" class="self-link"></a></h2>
<ul>
<li><p>A function-taking-a-callback is invoked from a stack frame that may not exist when return-value|exception is emitted</p></li>
<li><p>The only remaining fragment of the stack frame that invoked the function-taking-a-callback is the callback argument</p></li>
<li><p>The signals return-value|exception that would be delivered to the stack frame that invoked a function-taking-a-callback must be delivered to the callback argument</p></li>
</ul>
<h1 id="proposals"><span class="header-section-number">6</span> Proposals<a href="#proposals" class="self-link"></a></h1>
<p>There are designs that can support value and error and serendipitous-success for both library and language.</p>
<h2 id="library"><span class="header-section-number">6.1</span> Library<a href="#library" class="self-link"></a></h2>
<p>When adding async functions to the library there must be a way to represent a value and an error and serendipitous-success.</p>
<p>Currently the ways to represent value and error were covered in <a href="#stdoptional"><code>std::optional</code></a>, <a href="#fgh"><code>f(g(h()))</code></a>, <a href="#coroutine-generator">coroutine generator</a>, <a href="#callbacks">Callbacks</a> and <a href="#stack-unwinding">stack unwinding</a> above. Of these, the only one with a working solution for a value and an error and serendipitous-success is the <a href="#multiple-function-style">multiple function style</a> in <a href="#callbacks">Callbacks</a>. The <code>async_accept_completion</code> example is reproduced here for convenience:</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb65-1" title="1"><span class="kw">struct</span> async_accept_completion <span class="op">{</span></a>
<a class="sourceLine" id="cb65-2" title="2">  <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span>socket_type s<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="kw">noexcept</span>;</a>
<a class="sourceLine" id="cb65-3" title="3">  <span class="dt">void</span> error<span class="op">(</span>error_code<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="kw">noexcept</span>;</a>
<a class="sourceLine" id="cb65-4" title="4">  <span class="dt">void</span> error<span class="op">(</span>exception_ptr<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="kw">noexcept</span>;</a>
<a class="sourceLine" id="cb65-5" title="5">  <span class="dt">void</span> done<span class="op">()</span> <span class="op">&amp;&amp;</span> <span class="kw">noexcept</span>;</a>
<a class="sourceLine" id="cb65-6" title="6"><span class="op">}</span>;</a></code></pre></div>
<p>Where:</p>
<ul>
<li><code>operator()</code> is only called for success</li>
<li><code>error()</code> is only called for failure</li>
<li><code>done()</code> is only called for serendipitous-success</li>
</ul>
<p>Provides:</p>
<ul>
<li>each function can be specified to be called on a different execution agent</li>
<li>value types do not need to represent invalid or empty states</li>
<li>none of the functions are required to add branches and checks for errors or validity</li>
<li>all types are passed as function arguments with no required packing/unpacking</li>
<li>overloads of each method allow different types to be supported without use of <code>std::variant</code></li>
<li>overloads of each method allow different numbers of arguments to be supported without use of <code>std::optional</code> or <code>std::variant&lt;std::tuple&lt;&gt;&gt;</code></li>
</ul>
<h2 id="language"><span class="header-section-number">6.2</span> Language<a href="#language" class="self-link"></a></h2>
<p>As noted in <a href="#stdoptional"><code>std::optional</code></a> above, there is no language feature that supports serendipitous-success. Here are some thoughts on what this might look like in the language.</p>
<h3 id="co_done-catch_co_done"><span class="header-section-number">6.2.1</span> co_done &amp; catch_co_done<a href="#co_done-catch_co_done" class="self-link"></a></h3>
<p>One option is to tie this to coroutines, and add <code>co_done</code> to emit the signal, <code>operator co_done()</code> to customize the signal and <code>try {} catch_co_done() {}</code> to intercept the signal.</p>
<p>Pros: familiar to coroutines</p>
<p>Cons:</p>
<ul>
<li>limits usage to coroutines</li>
<li>explicit scope</li>
<li>requires adding try blocks to intercept a signal that is not an error</li>
</ul>
<h3 id="scope-library"><span class="header-section-number">6.2.2</span> scope library<a href="#scope-library" class="self-link"></a></h3>
<p>Another option is to provide a new model for handling implicit signals in a scope.</p>
<p>There is a library that is adding a new model for handling implicit signals in a scope. The scope library <span class="citation" data-cites="P0052R10">[<a href="#ref-P0052R10" role="doc-biblioref">P0052R10</a>]</span> introduces <code>scope_exit</code>, <code>scope_fail</code> and <code>scope_success</code>. These are used to introduce new implicit scopes (no braces required) and invoke a function at the end of that scope.</p>
<p>The paper contains a simple example:</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb66-1" title="1"><span class="dt">void</span> grow<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> v<span class="op">){</span></a>
<a class="sourceLine" id="cb66-2" title="2">  scope_success guard<span class="op">([]{</span> cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Good!&quot;</span> <span class="op">&lt;&lt;</span> endl; <span class="op">})</span>;</a>
<a class="sourceLine" id="cb66-3" title="3">  v<span class="op">.</span>resize<span class="op">(</span><span class="dv">1024</span><span class="op">)</span>;</a>
<a class="sourceLine" id="cb66-4" title="4"><span class="op">}</span></a></code></pre></div>
<p>Pros:</p>
<ul>
<li>familiar library</li>
<li>implicit scope</li>
<li>not limited to coroutines</li>
</ul>
<p>Cons:</p>
<ul>
<li>function has some restrictions since it is called from a destructor</li>
<li>depends on TLS state to detect success and fail, which may not be available on all platforms. Also, the detection can be confused when exceptions are transported or continuations resumed within the scope of an instance of the <code>scope_success</code> and <code>scope_fail</code> types.</li>
<li>there is no support for serendipitous-success and adding it would require adding more of the fragile TLS dependencies or a language feature.</li>
</ul>
<h3 id="scope_success-scope_fail-scope_done-blocks"><span class="header-section-number">6.2.3</span> scope_success, scope_fail, scope_done blocks<a href="#scope_success-scope_fail-scope_done-blocks" class="self-link"></a></h3>
<p>A language feature based on the <code>scope_guard</code> pattern would be another way to introduce support for fail/success/done interception.</p>
<p>bikeshedding aside..</p>
<p>Imagine that <code>break return</code> is a statement that returns from the current function with serendipitous-success.</p>
<p>Imagine that <code>scope_success</code>, <code>scope_fail</code> and <code>scope_done</code> were keywords that introduced statements that started an implicit scope (same rules as variable declarations) and introduced a block to run at the end of that scope. The <code>scope_..</code> blocks introduce a new scope within the current scope of the current function and can participate in the control flow of the current scope of the current function (using <code>goto</code>, <code>return</code>, <code>break return</code>, <code>break</code> and <code>continue</code>).</p>
<p>Finally, imagine that any type is allowed to implement <code>operator break return()</code>. <code>operator break return()</code> will be called when an object instance goes out of scope with serendipitous-success in flight.</p>
<p>Here is the example from the scope paper <span class="citation" data-cites="P0052R10">[<a href="#ref-P0052R10" role="doc-biblioref">P0052R10</a>]</span> with this proposal:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb67-1" title="1"><span class="dt">void</span> grow<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> v<span class="op">){</span></a>
<a class="sourceLine" id="cb67-2" title="2">  scope_success <span class="op">{</span> cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Good!&quot;</span> <span class="op">&lt;&lt;</span> endl; <span class="op">}</span>;</a>
<a class="sourceLine" id="cb67-3" title="3">  v<span class="op">.</span>resize<span class="op">(</span><span class="dv">1024</span><span class="op">)</span>;</a>
<a class="sourceLine" id="cb67-4" title="4"><span class="op">}</span></a></code></pre></div>
<p>Here is the example from <a href="#stdoptional"><code>std::optional</code></a> in this paper with this proposal:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb68-1" title="1"><span class="dt">int</span> op<span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb68-2" title="2">  <span class="cf">if</span> <span class="op">(!</span>has_feature<span class="op">())</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb68-3" title="3">    <span class="cf">break</span> <span class="cf">return</span>; <span class="co">// emits serendipitous-success</span></a>
<a class="sourceLine" id="cb68-4" title="4">  <span class="op">}</span></a>
<a class="sourceLine" id="cb68-5" title="5">  <span class="cf">return</span> feature<span class="op">()</span>;</a>
<a class="sourceLine" id="cb68-6" title="6"><span class="op">}</span></a>
<a class="sourceLine" id="cb68-7" title="7"></a>
<a class="sourceLine" id="cb68-8" title="8"><span class="dt">void</span> foo<span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb68-9" title="9">  <span class="co">// ..</span></a>
<a class="sourceLine" id="cb68-10" title="10">  scope_done <span class="op">{</span> cout <span class="op">&lt;&lt;</span> <span class="st">&quot;feature unsupported!&quot;</span> <span class="op">&lt;&lt;</span> endl; <span class="op">}</span>;</a>
<a class="sourceLine" id="cb68-11" title="11">  <span class="kw">auto</span> i <span class="op">=</span> op<span class="op">()</span>;</a>
<a class="sourceLine" id="cb68-12" title="12">  <span class="co">// use i..</span></a>
<a class="sourceLine" id="cb68-13" title="13"><span class="op">}</span> <span class="co">// jumps here, when the feature is </span></a>
<a class="sourceLine" id="cb68-14" title="14">  <span class="co">// not supported, runs scope_done and</span></a>
<a class="sourceLine" id="cb68-15" title="15">  <span class="co">// emits serendipitous-success</span></a>
<a class="sourceLine" id="cb68-16" title="16"></a>
<a class="sourceLine" id="cb68-17" title="17"><span class="dt">void</span> bar<span class="op">()</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb68-18" title="18">  <span class="co">// ..</span></a>
<a class="sourceLine" id="cb68-19" title="19">  scope_done <span class="op">{</span> <span class="cf">return</span>; <span class="op">}</span>;</a>
<a class="sourceLine" id="cb68-20" title="20">  <span class="kw">auto</span> i <span class="op">=</span> op<span class="op">()</span>;</a>
<a class="sourceLine" id="cb68-21" title="21">  <span class="co">// use i..</span></a>
<a class="sourceLine" id="cb68-22" title="22"><span class="op">}</span> <span class="co">// jumps here, when the feature is </span></a>
<a class="sourceLine" id="cb68-23" title="23">  <span class="co">// not supported in op(), runs the </span></a>
<a class="sourceLine" id="cb68-24" title="24">  <span class="co">// scope_done block which uses return </span></a>
<a class="sourceLine" id="cb68-25" title="25">  <span class="co">// to exit bar() normally. bar() does </span></a>
<a class="sourceLine" id="cb68-26" title="26">  <span class="co">// not emit serendipitous-success</span></a></code></pre></div>
<p>Pros:</p>
<ul>
<li>implicit scope</li>
<li>not limited to coroutines</li>
<li>safer than library solutions because the compiler+runtime owns the semantics</li>
<li>no restrictions on the block contents since they are not run in the context of a destructor.</li>
</ul>
<p>Cons:</p>
<ul>
<li>composition with existing functions that do not support serendipitous-success need the compiler+runtime to call `std::terminate()</li>
</ul>
<h3 id="afterthought-converting-undefined-behaviour-to-defined-behaviour"><span class="header-section-number">6.2.4</span> Afterthought: converting undefined behaviour to defined behaviour<a href="#afterthought-converting-undefined-behaviour-to-defined-behaviour" class="self-link"></a></h3>
<p>Something that has occurred only after imagining a language solution, is how language support for serendipitous-success would allow converting undefined-behaviour into defined-behaviour in a new and clean way. A method that could not return a value and should not throw an exception can use <code>break return</code> to return serendipitous-success. serendipitous-success can propagate up until handled without requiring any explicit code for serendipitous-success in the intermediate functions.</p>
<p>Some cooperation between compiler and runtime would be required to turn an unhandled serendipitous-success into <code>std::terminate()</code>. One example of an unhandled serendipitous-success would be when a calling function was compiled without support for serendipitous-success and a callee returned serendipitous-success. This case would need to result in <code>std::terminate()</code> and this would need to be enforced by the compiler+runtime of the callee not the caller.</p>
<h1 id="credits"><span class="header-section-number">7</span> Credits<a href="#credits" class="self-link"></a></h1>
<p>This paper was influenced by hosts of people over decades.</p>
<ul>
<li><strong>Marc Barbour</strong> and <strong>Mark Lawrence</strong> were fundamental to Kirk’s first attempt to design more regular callbacks in a COM environment.</li>
<li><strong>Aaron Lahman</strong> was involved in that first attempt as well and introduced Kirk to the Reactive-Extensions libraries because he saw the similarity.</li>
<li><strong>Erik Meijer</strong> and his team took a very different path to arrive at a destination that resonated strongly with Kirk’s goals</li>
<li><em>Microsoft Open Technologies Inc.</em> led by <strong>Jean Paoli</strong>, encouraged and supported Kirk’s subsequent investment in finishing Aaron’s C++ Rx prototype and then rewriting it to shift from interfaces to compile-time polymorphism.</li>
<li><strong>Ben Christensen</strong> drove changes to RxJava and his communication around those changes affected the design Kirk chose for rxcpp</li>
<li><strong>Grigorii Chudnov</strong>, <strong>Valery Kopylov</strong> and all the other amazing contributors to rxcpp over the years</li>
<li><strong>Eric Niebler</strong>, <strong>Lee Howes</strong> and <strong>Lewis Baker</strong> who more than anyone else contributed to the content of the motivation section of this paper</li>
<li><strong>Lewis Baker</strong>’s excellent <code>stop_source</code>/<code>stop_token</code> design in <span class="citation" data-cites="P0660R9">[<a href="#ref-P0660R9" role="doc-biblioref">P0660R9</a>]</span></li>
<li><em>CppCon</em>, <em>CppNow</em>, <em>CppRussia</em> and <em>CERN</em> (and the people behind those including; <strong>Jon Kalb</strong>, <strong>Bryce Adelstein-Lebach</strong>, <strong>Sergey Platonov</strong>, <strong>Axel Naumann</strong>) for all the opportunities to communicate the vision for cancellation in C++</li>
<li><strong>Gor Nishanov</strong> for the excellent coroutines in C++20 and the shout-outs and support for rxcpp over the years.</li>
<li><strong>Lisa Lippincott</strong> for coining ‘serendipitous-success’ to explain what the result of cancellation is rather than what it is not.</li>
</ul>
<p>`</p>
<h1 id="references"><span class="header-section-number">8</span> References<a href="#references" class="self-link"></a></h1>

<div id="refs" role="doc-bibliography">
<div id="ref-N4771">
<p>[N4771] Jonathan Wakely. 2018. Working Draft, C++ Extensions for Networking. <br />
<a href="https://wg21.link/n4771">https://wg21.link/n4771</a></p>
</div>
<div id="ref-P0052R10">
<p>[P0052R10] Peter Sommerlad, Andrew L. Sandoval. 2019. Generic Scope Guard and RAII Wrapper for the Standard Library. <br />
<a href="https://wg21.link/p0052r10">https://wg21.link/p0052r10</a></p>
</div>
<div id="ref-P0660R4">
<p>[P0660R4] Nicolai Josuttis, Herb Sutter, Anthony Williams. 2018. A Cooperatively Interruptible Joining Thread. <br />
<a href="https://wg21.link/p0660r4">https://wg21.link/p0660r4</a></p>
</div>
<div id="ref-P0660R9">
<p>[P0660R9] Nicolai Josuttis, Lewis Baker, Billy O’Neal, Herb Sutter, Anthony Williams. 2019. Stop Token and Joining Thread. <br />
<a href="https://wg21.link/p0660r9">https://wg21.link/p0660r9</a></p>
</div>
<div id="ref-P0876R5">
<p>[P0876R5] Oliver Kowalke, Nat Goodspeed. 2019. fiber_context - fibers without scheduler. <br />
<a href="https://wg21.link/p0876r5">https://wg21.link/p0876r5</a></p>
</div>
<div id="ref-P0876R6">
<p>[P0876R6] Oliver Kowalke, Nat Goodspeed. 2019. fiber_context - fibers without scheduler. <br />
<a href="https://wg21.link/p0876r6">https://wg21.link/p0876r6</a></p>
</div>
<div id="ref-P1055R0">
<p>[P1055R0] Kirk Shoop, Eric Niebler, Lee Howes. 2018. A Modest Executor Proposal. <br />
<a href="https://wg21.link/p1055r0">https://wg21.link/p1055r0</a></p>
</div>
<div id="ref-P1341R0">
<p>[P1341R0] Lewis Baker. 2018. Unifying Asynchronous APIs in the Standard Library. <br />
<a href="https://wg21.link/p1341r0">https://wg21.link/p1341r0</a></p>
</div>
<div id="ref-P1371R0">
<p>[P1371R0] Sergei Murzin, Michael Park, David Sankel, Dan Sarginson. 2019. Pattern Matching. <br />
<a href="https://wg21.link/p1371r0">https://wg21.link/p1371r0</a></p>
</div>
<div id="ref-P1660R0">
<p>[P1660R0] Jared Hoberock, Michael Garland, Bryce Adelstein Lelbach, Michał Dominiak, Eric Niebler, Kirk Shoop, Lewis Baker, Lee Howes, David S. Hollman, Gordon Brown. 2019. A Compromise Executor Design Sketch. <br />
<a href="https://wg21.link/p1660r0">https://wg21.link/p1660r0</a></p>
</div>
<div id="ref-P1678R0">
<p>[P1678R0] Kirk Shoop. 2019. Callbacks and Composition. <br />
<a href="https://wg21.link/p1678r0">https://wg21.link/p1678r0</a></p>
</div>
<div id="ref-P1745R0">
<p>[P1745R0] Lewis Baker. 2019. Coroutine changes for C++20 and beyond. <br />
<a href="https://wg21.link/p1745r0">https://wg21.link/p1745r0</a></p>
</div>
</div>
</div>
</div>
</body>
</html>
